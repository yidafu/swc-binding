// Auto-generated file. Do not edit. Generated at: 2025-11-19T22:42:22.987723

package dev.yidafu.swc.generated.dsl

import dev.yidafu.swc.generated.ArrayExpression
import dev.yidafu.swc.generated.ArrowFunctionExpression
import dev.yidafu.swc.generated.AssignmentExpression
import dev.yidafu.swc.generated.AwaitExpression
import dev.yidafu.swc.generated.BinaryExpression
import dev.yidafu.swc.generated.CallExpression
import dev.yidafu.swc.generated.ClassExpression
import dev.yidafu.swc.generated.ConditionalExpression
import dev.yidafu.swc.generated.FunctionExpression
import dev.yidafu.swc.generated.Identifier
import dev.yidafu.swc.generated.IdentifierImpl
import dev.yidafu.swc.generated.MemberExpression
import dev.yidafu.swc.generated.NewExpression
import dev.yidafu.swc.generated.ObjectExpression
import dev.yidafu.swc.generated.OptionalChainingExpression
import dev.yidafu.swc.generated.ParenthesisExpression
import dev.yidafu.swc.generated.PrivateName
import dev.yidafu.swc.generated.SequenceExpression
import dev.yidafu.swc.generated.Span
import dev.yidafu.swc.generated.SuperPropExpression
import dev.yidafu.swc.generated.TaggedTemplateExpression
import dev.yidafu.swc.generated.TemplateElement
import dev.yidafu.swc.generated.TemplateLiteral
import dev.yidafu.swc.generated.TemplateLiteralImpl
import dev.yidafu.swc.generated.ThisExpression
import dev.yidafu.swc.generated.TsAsExpression
import dev.yidafu.swc.generated.TsConstAssertion
import dev.yidafu.swc.generated.TsNonNullExpression
import dev.yidafu.swc.generated.TsSatisfiesExpression
import dev.yidafu.swc.generated.TsTypeAssertion
import dev.yidafu.swc.generated.UnaryExpression
import dev.yidafu.swc.generated.UpdateExpression
import dev.yidafu.swc.generated.YieldExpression
import kotlin.Unit

/**
 * OptionalChainingExpression#questionDotToken: Span?
 * extension function for create Span? -> Span
 */
public fun OptionalChainingExpression.span(block: Span.() -> Unit): Span = Span().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ThisExpression
 */
public fun OptionalChainingExpression.thisExpression(block: ThisExpression.() -> Unit):
    ThisExpression = ThisExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ArrayExpression
 */
public fun OptionalChainingExpression.arrayExpression(block: ArrayExpression.() -> Unit):
    ArrayExpression = ArrayExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ObjectExpression
 */
public fun OptionalChainingExpression.objectExpression(block: ObjectExpression.() -> Unit):
    ObjectExpression = ObjectExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> UnaryExpression
 */
public fun OptionalChainingExpression.unaryExpression(block: UnaryExpression.() -> Unit):
    UnaryExpression = UnaryExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> UpdateExpression
 */
public fun OptionalChainingExpression.updateExpression(block: UpdateExpression.() -> Unit):
    UpdateExpression = UpdateExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> BinaryExpression
 */
public fun OptionalChainingExpression.binaryExpression(block: BinaryExpression.() -> Unit):
    BinaryExpression = BinaryExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> FunctionExpression
 */
public fun OptionalChainingExpression.functionExpression(block: FunctionExpression.() -> Unit):
    FunctionExpression = FunctionExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ClassExpression
 */
public fun OptionalChainingExpression.classExpression(block: ClassExpression.() -> Unit):
    ClassExpression = ClassExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> AssignmentExpression
 */
public fun OptionalChainingExpression.assignmentExpression(block: AssignmentExpression.() -> Unit):
    AssignmentExpression = AssignmentExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> MemberExpression
 */
public fun OptionalChainingExpression.memberExpression(block: MemberExpression.() -> Unit):
    MemberExpression = MemberExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> SuperPropExpression
 */
public fun OptionalChainingExpression.superPropExpression(block: SuperPropExpression.() -> Unit):
    SuperPropExpression = SuperPropExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ConditionalExpression
 */
public
    fun OptionalChainingExpression.conditionalExpression(block: ConditionalExpression.() -> Unit):
    ConditionalExpression = ConditionalExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> CallExpression
 */
public fun OptionalChainingExpression.callExpression(block: CallExpression.() -> Unit):
    CallExpression = CallExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> NewExpression
 */
public fun OptionalChainingExpression.newExpression(block: NewExpression.() -> Unit): NewExpression
    = NewExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> SequenceExpression
 */
public fun OptionalChainingExpression.sequenceExpression(block: SequenceExpression.() -> Unit):
    SequenceExpression = SequenceExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ArrowFunctionExpression
 */
public
    fun OptionalChainingExpression.arrowFunctionExpression(block: ArrowFunctionExpression.() -> Unit):
    ArrowFunctionExpression = ArrowFunctionExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> YieldExpression
 */
public fun OptionalChainingExpression.yieldExpression(block: YieldExpression.() -> Unit):
    YieldExpression = YieldExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> AwaitExpression
 */
public fun OptionalChainingExpression.awaitExpression(block: AwaitExpression.() -> Unit):
    AwaitExpression = AwaitExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TaggedTemplateExpression
 */
public
    fun OptionalChainingExpression.taggedTemplateExpression(block: TaggedTemplateExpression.() -> Unit):
    TaggedTemplateExpression = TaggedTemplateExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TemplateElement
 */
public fun OptionalChainingExpression.templateElement(block: TemplateElement.() -> Unit):
    TemplateElement = TemplateElement().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> ParenthesisExpression
 */
public
    fun OptionalChainingExpression.parenthesisExpression(block: ParenthesisExpression.() -> Unit):
    ParenthesisExpression = ParenthesisExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> PrivateName
 */
public fun OptionalChainingExpression.privateName(block: PrivateName.() -> Unit): PrivateName =
    PrivateName().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TsAsExpression
 */
public fun OptionalChainingExpression.tsAsExpression(block: TsAsExpression.() -> Unit):
    TsAsExpression = TsAsExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TsSatisfiesExpression
 */
public
    fun OptionalChainingExpression.tsSatisfiesExpression(block: TsSatisfiesExpression.() -> Unit):
    TsSatisfiesExpression = TsSatisfiesExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TsTypeAssertion
 */
public fun OptionalChainingExpression.tsTypeAssertion(block: TsTypeAssertion.() -> Unit):
    TsTypeAssertion = TsTypeAssertion().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TsConstAssertion
 */
public fun OptionalChainingExpression.tsConstAssertion(block: TsConstAssertion.() -> Unit):
    TsConstAssertion = TsConstAssertion().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TsNonNullExpression
 */
public fun OptionalChainingExpression.tsNonNullExpression(block: TsNonNullExpression.() -> Unit):
    TsNonNullExpression = TsNonNullExpression().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> Identifier
 */
public fun OptionalChainingExpression.identifier(block: Identifier.() -> Unit): Identifier =
    IdentifierImpl().apply(block)

/**
 * OptionalChainingExpression#base: ExpressionBase?
 * extension function for create ExpressionBase? -> TemplateLiteral
 */
public fun OptionalChainingExpression.templateLiteral(block: TemplateLiteral.() -> Unit):
    TemplateLiteral = TemplateLiteralImpl().apply(block)

// Auto-generated file. Do not edit. Generated at: 2025-11-20T00:09:39.250049

package dev.yidafu.swc.generated.dsl

import dev.yidafu.swc.generated.ArrayExpression
import dev.yidafu.swc.generated.ArrayPattern
import dev.yidafu.swc.generated.ArrowFunctionExpression
import dev.yidafu.swc.generated.AssignmentExpression
import dev.yidafu.swc.generated.AssignmentPattern
import dev.yidafu.swc.generated.AssignmentPatternProperty
import dev.yidafu.swc.generated.AssignmentProperty
import dev.yidafu.swc.generated.AwaitExpression
import dev.yidafu.swc.generated.BigIntLiteral
import dev.yidafu.swc.generated.BinaryExpression
import dev.yidafu.swc.generated.BindingIdentifier
import dev.yidafu.swc.generated.BindingIdentifierImpl
import dev.yidafu.swc.generated.BlockStatement
import dev.yidafu.swc.generated.BlockStatementImpl
import dev.yidafu.swc.generated.BooleanLiteral
import dev.yidafu.swc.generated.BreakStatement
import dev.yidafu.swc.generated.CallExpression
import dev.yidafu.swc.generated.CatchClause
import dev.yidafu.swc.generated.ClassDeclaration
import dev.yidafu.swc.generated.ClassExpression
import dev.yidafu.swc.generated.ClassMethod
import dev.yidafu.swc.generated.ClassProperty
import dev.yidafu.swc.generated.ComputedPropName
import dev.yidafu.swc.generated.ConditionalExpression
import dev.yidafu.swc.generated.Constructor
import dev.yidafu.swc.generated.ContinueStatement
import dev.yidafu.swc.generated.DebuggerStatement
import dev.yidafu.swc.generated.Decorator
import dev.yidafu.swc.generated.DoWhileStatement
import dev.yidafu.swc.generated.EmptyStatement
import dev.yidafu.swc.generated.ExportAllDeclaration
import dev.yidafu.swc.generated.ExportDeclaration
import dev.yidafu.swc.generated.ExportDefaultDeclaration
import dev.yidafu.swc.generated.ExportDefaultExpression
import dev.yidafu.swc.generated.ExportDefaultSpecifier
import dev.yidafu.swc.generated.ExportNamedDeclaration
import dev.yidafu.swc.generated.ExportNamespaceSpecifier
import dev.yidafu.swc.generated.ExpressionStatement
import dev.yidafu.swc.generated.ForInStatement
import dev.yidafu.swc.generated.ForOfStatement
import dev.yidafu.swc.generated.ForStatement
import dev.yidafu.swc.generated.FunctionExpression
import dev.yidafu.swc.generated.GetterProperty
import dev.yidafu.swc.generated.Identifier
import dev.yidafu.swc.generated.IdentifierImpl
import dev.yidafu.swc.generated.IfStatement
import dev.yidafu.swc.generated.ImportDeclaration
import dev.yidafu.swc.generated.ImportDefaultSpecifier
import dev.yidafu.swc.generated.ImportNamespaceSpecifier
import dev.yidafu.swc.generated.Invalid
import dev.yidafu.swc.generated.JSXAttribute
import dev.yidafu.swc.generated.JSXClosingElement
import dev.yidafu.swc.generated.JSXClosingElementImpl
import dev.yidafu.swc.generated.JSXClosingFragment
import dev.yidafu.swc.generated.JSXElement
import dev.yidafu.swc.generated.JSXEmptyExpression
import dev.yidafu.swc.generated.JSXExpressionContainer
import dev.yidafu.swc.generated.JSXFragment
import dev.yidafu.swc.generated.JSXMemberExpression
import dev.yidafu.swc.generated.JSXNamespacedName
import dev.yidafu.swc.generated.JSXOpeningElement
import dev.yidafu.swc.generated.JSXOpeningElementImpl
import dev.yidafu.swc.generated.JSXOpeningFragment
import dev.yidafu.swc.generated.JSXSpreadChild
import dev.yidafu.swc.generated.JSXText
import dev.yidafu.swc.generated.JsImport
import dev.yidafu.swc.generated.JsSuper
import dev.yidafu.swc.generated.KeyValuePatternProperty
import dev.yidafu.swc.generated.KeyValueProperty
import dev.yidafu.swc.generated.LabeledStatement
import dev.yidafu.swc.generated.MemberExpression
import dev.yidafu.swc.generated.MetaProperty
import dev.yidafu.swc.generated.MethodProperty
import dev.yidafu.swc.generated.Module
import dev.yidafu.swc.generated.NamedExportSpecifier
import dev.yidafu.swc.generated.NamedImportSpecifier
import dev.yidafu.swc.generated.NewExpression
import dev.yidafu.swc.generated.NullLiteral
import dev.yidafu.swc.generated.NumericLiteral
import dev.yidafu.swc.generated.ObjectExpression
import dev.yidafu.swc.generated.ObjectPattern
import dev.yidafu.swc.generated.OptionalChainingExpression
import dev.yidafu.swc.generated.Param
import dev.yidafu.swc.generated.ParamImpl
import dev.yidafu.swc.generated.ParenthesisExpression
import dev.yidafu.swc.generated.PrivateMethod
import dev.yidafu.swc.generated.PrivateName
import dev.yidafu.swc.generated.PrivateProperty
import dev.yidafu.swc.generated.RegExpLiteral
import dev.yidafu.swc.generated.RestElement
import dev.yidafu.swc.generated.ReturnStatement
import dev.yidafu.swc.generated.Script
import dev.yidafu.swc.generated.SequenceExpression
import dev.yidafu.swc.generated.SetterProperty
import dev.yidafu.swc.generated.SpreadElement
import dev.yidafu.swc.generated.StaticBlock
import dev.yidafu.swc.generated.StringLiteral
import dev.yidafu.swc.generated.SuperPropExpression
import dev.yidafu.swc.generated.SwitchCase
import dev.yidafu.swc.generated.SwitchStatement
import dev.yidafu.swc.generated.TaggedTemplateExpression
import dev.yidafu.swc.generated.TemplateElement
import dev.yidafu.swc.generated.TemplateLiteral
import dev.yidafu.swc.generated.TemplateLiteralImpl
import dev.yidafu.swc.generated.ThisExpression
import dev.yidafu.swc.generated.ThrowStatement
import dev.yidafu.swc.generated.TryStatement
import dev.yidafu.swc.generated.TsArrayType
import dev.yidafu.swc.generated.TsAsExpression
import dev.yidafu.swc.generated.TsCallSignatureDeclaration
import dev.yidafu.swc.generated.TsConditionalType
import dev.yidafu.swc.generated.TsConstAssertion
import dev.yidafu.swc.generated.TsConstructSignatureDeclaration
import dev.yidafu.swc.generated.TsConstructorType
import dev.yidafu.swc.generated.TsEnumDeclaration
import dev.yidafu.swc.generated.TsEnumMember
import dev.yidafu.swc.generated.TsExportAssignment
import dev.yidafu.swc.generated.TsExpressionWithTypeArguments
import dev.yidafu.swc.generated.TsExternalModuleReference
import dev.yidafu.swc.generated.TsFunctionType
import dev.yidafu.swc.generated.TsGetterSignature
import dev.yidafu.swc.generated.TsImportEqualsDeclaration
import dev.yidafu.swc.generated.TsImportType
import dev.yidafu.swc.generated.TsIndexSignature
import dev.yidafu.swc.generated.TsIndexedAccessType
import dev.yidafu.swc.generated.TsInferType
import dev.yidafu.swc.generated.TsInstantiation
import dev.yidafu.swc.generated.TsInterfaceBody
import dev.yidafu.swc.generated.TsInterfaceDeclaration
import dev.yidafu.swc.generated.TsIntersectionType
import dev.yidafu.swc.generated.TsKeywordType
import dev.yidafu.swc.generated.TsLiteralType
import dev.yidafu.swc.generated.TsMappedType
import dev.yidafu.swc.generated.TsMethodSignature
import dev.yidafu.swc.generated.TsModuleBlock
import dev.yidafu.swc.generated.TsModuleDeclaration
import dev.yidafu.swc.generated.TsNamespaceDeclaration
import dev.yidafu.swc.generated.TsNamespaceExportDeclaration
import dev.yidafu.swc.generated.TsNonNullExpression
import dev.yidafu.swc.generated.TsOptionalType
import dev.yidafu.swc.generated.TsParameterProperty
import dev.yidafu.swc.generated.TsParenthesizedType
import dev.yidafu.swc.generated.TsPropertySignature
import dev.yidafu.swc.generated.TsQualifiedName
import dev.yidafu.swc.generated.TsRestType
import dev.yidafu.swc.generated.TsSatisfiesExpression
import dev.yidafu.swc.generated.TsSetterSignature
import dev.yidafu.swc.generated.TsTemplateLiteralType
import dev.yidafu.swc.generated.TsTemplateLiteralTypeImpl
import dev.yidafu.swc.generated.TsThisType
import dev.yidafu.swc.generated.TsTupleElement
import dev.yidafu.swc.generated.TsTupleType
import dev.yidafu.swc.generated.TsTypeAliasDeclaration
import dev.yidafu.swc.generated.TsTypeAnnotation
import dev.yidafu.swc.generated.TsTypeAssertion
import dev.yidafu.swc.generated.TsTypeLiteral
import dev.yidafu.swc.generated.TsTypeOperator
import dev.yidafu.swc.generated.TsTypeParameter
import dev.yidafu.swc.generated.TsTypeParameterDeclaration
import dev.yidafu.swc.generated.TsTypeParameterInstantiation
import dev.yidafu.swc.generated.TsTypePredicate
import dev.yidafu.swc.generated.TsTypeQuery
import dev.yidafu.swc.generated.TsTypeReference
import dev.yidafu.swc.generated.TsUnionType
import dev.yidafu.swc.generated.UnaryExpression
import dev.yidafu.swc.generated.UpdateExpression
import dev.yidafu.swc.generated.VariableDeclaration
import dev.yidafu.swc.generated.VariableDeclarator
import dev.yidafu.swc.generated.VariableDeclaratorImpl
import dev.yidafu.swc.generated.WhileStatement
import dev.yidafu.swc.generated.WithStatement
import dev.yidafu.swc.generated.YieldExpression
import kotlin.Unit

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> StringLiteral
 */
public fun Constructor.stringLiteral(block: StringLiteral.() -> Unit): StringLiteral =
    StringLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> NumericLiteral
 */
public fun Constructor.numericLiteral(block: NumericLiteral.() -> Unit): NumericLiteral =
    NumericLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> BigIntLiteral
 */
public fun Constructor.bigIntLiteral(block: BigIntLiteral.() -> Unit): BigIntLiteral =
    BigIntLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ComputedPropName
 */
public fun Constructor.computedPropName(block: ComputedPropName.() -> Unit): ComputedPropName =
    ComputedPropName().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> Identifier
 */
public fun Constructor.identifier(block: Identifier.() -> Unit): Identifier =
    IdentifierImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> StaticBlock
 */
public fun Constructor.staticBlock(block: StaticBlock.() -> Unit): StaticBlock =
    StaticBlock().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> Decorator
 */
public fun Constructor.decorator(block: Decorator.() -> Unit): Decorator = Decorator().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ClassDeclaration
 */
public fun Constructor.classDeclaration(block: ClassDeclaration.() -> Unit): ClassDeclaration =
    ClassDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> VariableDeclaration
 */
public fun Constructor.variableDeclaration(block: VariableDeclaration.() -> Unit):
    VariableDeclaration = VariableDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> SpreadElement
 */
public fun Constructor.spreadElement(block: SpreadElement.() -> Unit): SpreadElement =
    SpreadElement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JsSuper
 */
public fun Constructor.jsSuper(block: JsSuper.() -> Unit): JsSuper = JsSuper().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JsImport
 */
public fun Constructor.jsImport(block: JsImport.() -> Unit): JsImport = JsImport().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> MetaProperty
 */
public fun Constructor.metaProperty(block: MetaProperty.() -> Unit): MetaProperty =
    MetaProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXMemberExpression
 */
public fun Constructor.jSXMemberExpression(block: JSXMemberExpression.() -> Unit):
    JSXMemberExpression = JSXMemberExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXNamespacedName
 */
public fun Constructor.jSXNamespacedName(block: JSXNamespacedName.() -> Unit): JSXNamespacedName =
    JSXNamespacedName().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXEmptyExpression
 */
public fun Constructor.jSXEmptyExpression(block: JSXEmptyExpression.() -> Unit): JSXEmptyExpression
    = JSXEmptyExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXExpressionContainer
 */
public fun Constructor.jSXExpressionContainer(block: JSXExpressionContainer.() -> Unit):
    JSXExpressionContainer = JSXExpressionContainer().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXSpreadChild
 */
public fun Constructor.jSXSpreadChild(block: JSXSpreadChild.() -> Unit): JSXSpreadChild =
    JSXSpreadChild().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXAttribute
 */
public fun Constructor.jSXAttribute(block: JSXAttribute.() -> Unit): JSXAttribute =
    JSXAttribute().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXText
 */
public fun Constructor.jSXText(block: JSXText.() -> Unit): JSXText = JSXText().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXElement
 */
public fun Constructor.jSXElement(block: JSXElement.() -> Unit): JSXElement =
    JSXElement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXFragment
 */
public fun Constructor.jSXFragment(block: JSXFragment.() -> Unit): JSXFragment =
    JSXFragment().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXOpeningFragment
 */
public fun Constructor.jSXOpeningFragment(block: JSXOpeningFragment.() -> Unit): JSXOpeningFragment
    = JSXOpeningFragment().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXClosingFragment
 */
public fun Constructor.jSXClosingFragment(block: JSXClosingFragment.() -> Unit): JSXClosingFragment
    = JSXClosingFragment().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> BooleanLiteral
 */
public fun Constructor.booleanLiteral(block: BooleanLiteral.() -> Unit): BooleanLiteral =
    BooleanLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> NullLiteral
 */
public fun Constructor.nullLiteral(block: NullLiteral.() -> Unit): NullLiteral =
    NullLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> RegExpLiteral
 */
public fun Constructor.regExpLiteral(block: RegExpLiteral.() -> Unit): RegExpLiteral =
    RegExpLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportDefaultExpression
 */
public fun Constructor.exportDefaultExpression(block: ExportDefaultExpression.() -> Unit):
    ExportDefaultExpression = ExportDefaultExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportDeclaration
 */
public fun Constructor.exportDeclaration(block: ExportDeclaration.() -> Unit): ExportDeclaration =
    ExportDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ImportDeclaration
 */
public fun Constructor.importDeclaration(block: ImportDeclaration.() -> Unit): ImportDeclaration =
    ImportDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportAllDeclaration
 */
public fun Constructor.exportAllDeclaration(block: ExportAllDeclaration.() -> Unit):
    ExportAllDeclaration = ExportAllDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportNamedDeclaration
 */
public fun Constructor.exportNamedDeclaration(block: ExportNamedDeclaration.() -> Unit):
    ExportNamedDeclaration = ExportNamedDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportDefaultDeclaration
 */
public fun Constructor.exportDefaultDeclaration(block: ExportDefaultDeclaration.() -> Unit):
    ExportDefaultDeclaration = ExportDefaultDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ImportDefaultSpecifier
 */
public fun Constructor.importDefaultSpecifier(block: ImportDefaultSpecifier.() -> Unit):
    ImportDefaultSpecifier = ImportDefaultSpecifier().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ImportNamespaceSpecifier
 */
public fun Constructor.importNamespaceSpecifier(block: ImportNamespaceSpecifier.() -> Unit):
    ImportNamespaceSpecifier = ImportNamespaceSpecifier().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> NamedImportSpecifier
 */
public fun Constructor.namedImportSpecifier(block: NamedImportSpecifier.() -> Unit):
    NamedImportSpecifier = NamedImportSpecifier().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportNamespaceSpecifier
 */
public fun Constructor.exportNamespaceSpecifier(block: ExportNamespaceSpecifier.() -> Unit):
    ExportNamespaceSpecifier = ExportNamespaceSpecifier().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExportDefaultSpecifier
 */
public fun Constructor.exportDefaultSpecifier(block: ExportDefaultSpecifier.() -> Unit):
    ExportDefaultSpecifier = ExportDefaultSpecifier().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> NamedExportSpecifier
 */
public fun Constructor.namedExportSpecifier(block: NamedExportSpecifier.() -> Unit):
    NamedExportSpecifier = NamedExportSpecifier().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> Module
 */
public fun Constructor.module(block: Module.() -> Unit): Module = Module().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> Script
 */
public fun Constructor.script(block: Script.() -> Unit): Script = Script().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> KeyValuePatternProperty
 */
public fun Constructor.keyValuePatternProperty(block: KeyValuePatternProperty.() -> Unit):
    KeyValuePatternProperty = KeyValuePatternProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> AssignmentPatternProperty
 */
public fun Constructor.assignmentPatternProperty(block: AssignmentPatternProperty.() -> Unit):
    AssignmentPatternProperty = AssignmentPatternProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> AssignmentProperty
 */
public fun Constructor.assignmentProperty(block: AssignmentProperty.() -> Unit): AssignmentProperty
    = AssignmentProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ExpressionStatement
 */
public fun Constructor.expressionStatement(block: ExpressionStatement.() -> Unit):
    ExpressionStatement = ExpressionStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> EmptyStatement
 */
public fun Constructor.emptyStatement(block: EmptyStatement.() -> Unit): EmptyStatement =
    EmptyStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> DebuggerStatement
 */
public fun Constructor.debuggerStatement(block: DebuggerStatement.() -> Unit): DebuggerStatement =
    DebuggerStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> WithStatement
 */
public fun Constructor.withStatement(block: WithStatement.() -> Unit): WithStatement =
    WithStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ReturnStatement
 */
public fun Constructor.returnStatement(block: ReturnStatement.() -> Unit): ReturnStatement =
    ReturnStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> LabeledStatement
 */
public fun Constructor.labeledStatement(block: LabeledStatement.() -> Unit): LabeledStatement =
    LabeledStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> BreakStatement
 */
public fun Constructor.breakStatement(block: BreakStatement.() -> Unit): BreakStatement =
    BreakStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ContinueStatement
 */
public fun Constructor.continueStatement(block: ContinueStatement.() -> Unit): ContinueStatement =
    ContinueStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> IfStatement
 */
public fun Constructor.ifStatement(block: IfStatement.() -> Unit): IfStatement =
    IfStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> SwitchStatement
 */
public fun Constructor.switchStatement(block: SwitchStatement.() -> Unit): SwitchStatement =
    SwitchStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ThrowStatement
 */
public fun Constructor.throwStatement(block: ThrowStatement.() -> Unit): ThrowStatement =
    ThrowStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TryStatement
 */
public fun Constructor.tryStatement(block: TryStatement.() -> Unit): TryStatement =
    TryStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> WhileStatement
 */
public fun Constructor.whileStatement(block: WhileStatement.() -> Unit): WhileStatement =
    WhileStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> DoWhileStatement
 */
public fun Constructor.doWhileStatement(block: DoWhileStatement.() -> Unit): DoWhileStatement =
    DoWhileStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ForStatement
 */
public fun Constructor.forStatement(block: ForStatement.() -> Unit): ForStatement =
    ForStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ForInStatement
 */
public fun Constructor.forInStatement(block: ForInStatement.() -> Unit): ForInStatement =
    ForInStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ForOfStatement
 */
public fun Constructor.forOfStatement(block: ForOfStatement.() -> Unit): ForOfStatement =
    ForOfStatement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> SwitchCase
 */
public fun Constructor.switchCase(block: SwitchCase.() -> Unit): SwitchCase =
    SwitchCase().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> CatchClause
 */
public fun Constructor.catchClause(block: CatchClause.() -> Unit): CatchClause =
    CatchClause().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeAnnotation
 */
public fun Constructor.tsTypeAnnotation(block: TsTypeAnnotation.() -> Unit): TsTypeAnnotation =
    TsTypeAnnotation().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeParameterDeclaration
 */
public fun Constructor.tsTypeParameterDeclaration(block: TsTypeParameterDeclaration.() -> Unit):
    TsTypeParameterDeclaration = TsTypeParameterDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeParameter
 */
public fun Constructor.tsTypeParameter(block: TsTypeParameter.() -> Unit): TsTypeParameter =
    TsTypeParameter().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeParameterInstantiation
 */
public fun Constructor.tsTypeParameterInstantiation(block: TsTypeParameterInstantiation.() -> Unit):
    TsTypeParameterInstantiation = TsTypeParameterInstantiation().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsParameterProperty
 */
public fun Constructor.tsParameterProperty(block: TsParameterProperty.() -> Unit):
    TsParameterProperty = TsParameterProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsQualifiedName
 */
public fun Constructor.tsQualifiedName(block: TsQualifiedName.() -> Unit): TsQualifiedName =
    TsQualifiedName().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsCallSignatureDeclaration
 */
public fun Constructor.tsCallSignatureDeclaration(block: TsCallSignatureDeclaration.() -> Unit):
    TsCallSignatureDeclaration = TsCallSignatureDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsConstructSignatureDeclaration
 */
public
    fun Constructor.tsConstructSignatureDeclaration(block: TsConstructSignatureDeclaration.() -> Unit):
    TsConstructSignatureDeclaration = TsConstructSignatureDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsPropertySignature
 */
public fun Constructor.tsPropertySignature(block: TsPropertySignature.() -> Unit):
    TsPropertySignature = TsPropertySignature().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsGetterSignature
 */
public fun Constructor.tsGetterSignature(block: TsGetterSignature.() -> Unit): TsGetterSignature =
    TsGetterSignature().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsSetterSignature
 */
public fun Constructor.tsSetterSignature(block: TsSetterSignature.() -> Unit): TsSetterSignature =
    TsSetterSignature().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsMethodSignature
 */
public fun Constructor.tsMethodSignature(block: TsMethodSignature.() -> Unit): TsMethodSignature =
    TsMethodSignature().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsIndexSignature
 */
public fun Constructor.tsIndexSignature(block: TsIndexSignature.() -> Unit): TsIndexSignature =
    TsIndexSignature().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsKeywordType
 */
public fun Constructor.tsKeywordType(block: TsKeywordType.() -> Unit): TsKeywordType =
    TsKeywordType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsThisType
 */
public fun Constructor.tsThisType(block: TsThisType.() -> Unit): TsThisType =
    TsThisType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsFunctionType
 */
public fun Constructor.tsFunctionType(block: TsFunctionType.() -> Unit): TsFunctionType =
    TsFunctionType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsConstructorType
 */
public fun Constructor.tsConstructorType(block: TsConstructorType.() -> Unit): TsConstructorType =
    TsConstructorType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeReference
 */
public fun Constructor.tsTypeReference(block: TsTypeReference.() -> Unit): TsTypeReference =
    TsTypeReference().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypePredicate
 */
public fun Constructor.tsTypePredicate(block: TsTypePredicate.() -> Unit): TsTypePredicate =
    TsTypePredicate().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsImportType
 */
public fun Constructor.tsImportType(block: TsImportType.() -> Unit): TsImportType =
    TsImportType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeQuery
 */
public fun Constructor.tsTypeQuery(block: TsTypeQuery.() -> Unit): TsTypeQuery =
    TsTypeQuery().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeLiteral
 */
public fun Constructor.tsTypeLiteral(block: TsTypeLiteral.() -> Unit): TsTypeLiteral =
    TsTypeLiteral().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsArrayType
 */
public fun Constructor.tsArrayType(block: TsArrayType.() -> Unit): TsArrayType =
    TsArrayType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTupleType
 */
public fun Constructor.tsTupleType(block: TsTupleType.() -> Unit): TsTupleType =
    TsTupleType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTupleElement
 */
public fun Constructor.tsTupleElement(block: TsTupleElement.() -> Unit): TsTupleElement =
    TsTupleElement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsOptionalType
 */
public fun Constructor.tsOptionalType(block: TsOptionalType.() -> Unit): TsOptionalType =
    TsOptionalType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsRestType
 */
public fun Constructor.tsRestType(block: TsRestType.() -> Unit): TsRestType =
    TsRestType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsUnionType
 */
public fun Constructor.tsUnionType(block: TsUnionType.() -> Unit): TsUnionType =
    TsUnionType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsIntersectionType
 */
public fun Constructor.tsIntersectionType(block: TsIntersectionType.() -> Unit): TsIntersectionType
    = TsIntersectionType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsConditionalType
 */
public fun Constructor.tsConditionalType(block: TsConditionalType.() -> Unit): TsConditionalType =
    TsConditionalType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsInferType
 */
public fun Constructor.tsInferType(block: TsInferType.() -> Unit): TsInferType =
    TsInferType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsParenthesizedType
 */
public fun Constructor.tsParenthesizedType(block: TsParenthesizedType.() -> Unit):
    TsParenthesizedType = TsParenthesizedType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeOperator
 */
public fun Constructor.tsTypeOperator(block: TsTypeOperator.() -> Unit): TsTypeOperator =
    TsTypeOperator().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsIndexedAccessType
 */
public fun Constructor.tsIndexedAccessType(block: TsIndexedAccessType.() -> Unit):
    TsIndexedAccessType = TsIndexedAccessType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsMappedType
 */
public fun Constructor.tsMappedType(block: TsMappedType.() -> Unit): TsMappedType =
    TsMappedType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsLiteralType
 */
public fun Constructor.tsLiteralType(block: TsLiteralType.() -> Unit): TsLiteralType =
    TsLiteralType().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsInterfaceDeclaration
 */
public fun Constructor.tsInterfaceDeclaration(block: TsInterfaceDeclaration.() -> Unit):
    TsInterfaceDeclaration = TsInterfaceDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsInterfaceBody
 */
public fun Constructor.tsInterfaceBody(block: TsInterfaceBody.() -> Unit): TsInterfaceBody =
    TsInterfaceBody().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsExpressionWithTypeArguments
 */
public
    fun Constructor.tsExpressionWithTypeArguments(block: TsExpressionWithTypeArguments.() -> Unit):
    TsExpressionWithTypeArguments = TsExpressionWithTypeArguments().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeAliasDeclaration
 */
public fun Constructor.tsTypeAliasDeclaration(block: TsTypeAliasDeclaration.() -> Unit):
    TsTypeAliasDeclaration = TsTypeAliasDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsEnumDeclaration
 */
public fun Constructor.tsEnumDeclaration(block: TsEnumDeclaration.() -> Unit): TsEnumDeclaration =
    TsEnumDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsEnumMember
 */
public fun Constructor.tsEnumMember(block: TsEnumMember.() -> Unit): TsEnumMember =
    TsEnumMember().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsModuleDeclaration
 */
public fun Constructor.tsModuleDeclaration(block: TsModuleDeclaration.() -> Unit):
    TsModuleDeclaration = TsModuleDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsModuleBlock
 */
public fun Constructor.tsModuleBlock(block: TsModuleBlock.() -> Unit): TsModuleBlock =
    TsModuleBlock().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsNamespaceDeclaration
 */
public fun Constructor.tsNamespaceDeclaration(block: TsNamespaceDeclaration.() -> Unit):
    TsNamespaceDeclaration = TsNamespaceDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsImportEqualsDeclaration
 */
public fun Constructor.tsImportEqualsDeclaration(block: TsImportEqualsDeclaration.() -> Unit):
    TsImportEqualsDeclaration = TsImportEqualsDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsExternalModuleReference
 */
public fun Constructor.tsExternalModuleReference(block: TsExternalModuleReference.() -> Unit):
    TsExternalModuleReference = TsExternalModuleReference().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsExportAssignment
 */
public fun Constructor.tsExportAssignment(block: TsExportAssignment.() -> Unit): TsExportAssignment
    = TsExportAssignment().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsNamespaceExportDeclaration
 */
public fun Constructor.tsNamespaceExportDeclaration(block: TsNamespaceExportDeclaration.() -> Unit):
    TsNamespaceExportDeclaration = TsNamespaceExportDeclaration().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsInstantiation
 */
public fun Constructor.tsInstantiation(block: TsInstantiation.() -> Unit): TsInstantiation =
    TsInstantiation().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> Invalid
 */
public fun Constructor.invalid(block: Invalid.() -> Unit): Invalid = Invalid().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ClassProperty
 */
public fun Constructor.classProperty(block: ClassProperty.() -> Unit): ClassProperty =
    ClassProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> PrivateProperty
 */
public fun Constructor.privateProperty(block: PrivateProperty.() -> Unit): PrivateProperty =
    PrivateProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ClassMethod
 */
public fun Constructor.classMethod(block: ClassMethod.() -> Unit): ClassMethod =
    ClassMethod().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> PrivateMethod
 */
public fun Constructor.privateMethod(block: PrivateMethod.() -> Unit): PrivateMethod =
    PrivateMethod().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> OptionalChainingExpression
 */
public fun Constructor.optionalChainingExpression(block: OptionalChainingExpression.() -> Unit):
    OptionalChainingExpression = OptionalChainingExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ThisExpression
 */
public fun Constructor.thisExpression(block: ThisExpression.() -> Unit): ThisExpression =
    ThisExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ArrayExpression
 */
public fun Constructor.arrayExpression(block: ArrayExpression.() -> Unit): ArrayExpression =
    ArrayExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ObjectExpression
 */
public fun Constructor.objectExpression(block: ObjectExpression.() -> Unit): ObjectExpression =
    ObjectExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> UnaryExpression
 */
public fun Constructor.unaryExpression(block: UnaryExpression.() -> Unit): UnaryExpression =
    UnaryExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> UpdateExpression
 */
public fun Constructor.updateExpression(block: UpdateExpression.() -> Unit): UpdateExpression =
    UpdateExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> BinaryExpression
 */
public fun Constructor.binaryExpression(block: BinaryExpression.() -> Unit): BinaryExpression =
    BinaryExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> FunctionExpression
 */
public fun Constructor.functionExpression(block: FunctionExpression.() -> Unit): FunctionExpression
    = FunctionExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ClassExpression
 */
public fun Constructor.classExpression(block: ClassExpression.() -> Unit): ClassExpression =
    ClassExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> AssignmentExpression
 */
public fun Constructor.assignmentExpression(block: AssignmentExpression.() -> Unit):
    AssignmentExpression = AssignmentExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> MemberExpression
 */
public fun Constructor.memberExpression(block: MemberExpression.() -> Unit): MemberExpression =
    MemberExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> SuperPropExpression
 */
public fun Constructor.superPropExpression(block: SuperPropExpression.() -> Unit):
    SuperPropExpression = SuperPropExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ConditionalExpression
 */
public fun Constructor.conditionalExpression(block: ConditionalExpression.() -> Unit):
    ConditionalExpression = ConditionalExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> CallExpression
 */
public fun Constructor.callExpression(block: CallExpression.() -> Unit): CallExpression =
    CallExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> NewExpression
 */
public fun Constructor.newExpression(block: NewExpression.() -> Unit): NewExpression =
    NewExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> SequenceExpression
 */
public fun Constructor.sequenceExpression(block: SequenceExpression.() -> Unit): SequenceExpression
    = SequenceExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ArrowFunctionExpression
 */
public fun Constructor.arrowFunctionExpression(block: ArrowFunctionExpression.() -> Unit):
    ArrowFunctionExpression = ArrowFunctionExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> YieldExpression
 */
public fun Constructor.yieldExpression(block: YieldExpression.() -> Unit): YieldExpression =
    YieldExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> AwaitExpression
 */
public fun Constructor.awaitExpression(block: AwaitExpression.() -> Unit): AwaitExpression =
    AwaitExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TaggedTemplateExpression
 */
public fun Constructor.taggedTemplateExpression(block: TaggedTemplateExpression.() -> Unit):
    TaggedTemplateExpression = TaggedTemplateExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TemplateElement
 */
public fun Constructor.templateElement(block: TemplateElement.() -> Unit): TemplateElement =
    TemplateElement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ParenthesisExpression
 */
public fun Constructor.parenthesisExpression(block: ParenthesisExpression.() -> Unit):
    ParenthesisExpression = ParenthesisExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> PrivateName
 */
public fun Constructor.privateName(block: PrivateName.() -> Unit): PrivateName =
    PrivateName().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsAsExpression
 */
public fun Constructor.tsAsExpression(block: TsAsExpression.() -> Unit): TsAsExpression =
    TsAsExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsSatisfiesExpression
 */
public fun Constructor.tsSatisfiesExpression(block: TsSatisfiesExpression.() -> Unit):
    TsSatisfiesExpression = TsSatisfiesExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTypeAssertion
 */
public fun Constructor.tsTypeAssertion(block: TsTypeAssertion.() -> Unit): TsTypeAssertion =
    TsTypeAssertion().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsConstAssertion
 */
public fun Constructor.tsConstAssertion(block: TsConstAssertion.() -> Unit): TsConstAssertion =
    TsConstAssertion().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsNonNullExpression
 */
public fun Constructor.tsNonNullExpression(block: TsNonNullExpression.() -> Unit):
    TsNonNullExpression = TsNonNullExpression().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ArrayPattern
 */
public fun Constructor.arrayPattern(block: ArrayPattern.() -> Unit): ArrayPattern =
    ArrayPattern().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> ObjectPattern
 */
public fun Constructor.objectPattern(block: ObjectPattern.() -> Unit): ObjectPattern =
    ObjectPattern().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> AssignmentPattern
 */
public fun Constructor.assignmentPattern(block: AssignmentPattern.() -> Unit): AssignmentPattern =
    AssignmentPattern().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> RestElement
 */
public fun Constructor.restElement(block: RestElement.() -> Unit): RestElement =
    RestElement().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> KeyValueProperty
 */
public fun Constructor.keyValueProperty(block: KeyValueProperty.() -> Unit): KeyValueProperty =
    KeyValueProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> GetterProperty
 */
public fun Constructor.getterProperty(block: GetterProperty.() -> Unit): GetterProperty =
    GetterProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> SetterProperty
 */
public fun Constructor.setterProperty(block: SetterProperty.() -> Unit): SetterProperty =
    SetterProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> MethodProperty
 */
public fun Constructor.methodProperty(block: MethodProperty.() -> Unit): MethodProperty =
    MethodProperty().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> Param
 */
public fun Constructor.`param`(block: Param.() -> Unit): Param = ParamImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> VariableDeclarator
 */
public fun Constructor.variableDeclarator(block: VariableDeclarator.() -> Unit): VariableDeclarator
    = VariableDeclaratorImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXOpeningElement
 */
public fun Constructor.jSXOpeningElement(block: JSXOpeningElement.() -> Unit): JSXOpeningElement =
    JSXOpeningElementImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> JSXClosingElement
 */
public fun Constructor.jSXClosingElement(block: JSXClosingElement.() -> Unit): JSXClosingElement =
    JSXClosingElementImpl().apply(block)

/**
 * Constructor#body: BlockStatement?
 * extension function for create BlockStatement? -> BlockStatement
 */
public fun Constructor.blockStatement(block: BlockStatement.() -> Unit): BlockStatement =
    BlockStatementImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TsTemplateLiteralType
 */
public fun Constructor.tsTemplateLiteralType(block: TsTemplateLiteralType.() -> Unit):
    TsTemplateLiteralType = TsTemplateLiteralTypeImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> TemplateLiteral
 */
public fun Constructor.templateLiteral(block: TemplateLiteral.() -> Unit): TemplateLiteral =
    TemplateLiteralImpl().apply(block)

/**
 * Constructor#params: Array<Node>?
 * extension function for create Array<Node>? -> BindingIdentifier
 */
public fun Constructor.bindingIdentifier(block: BindingIdentifier.() -> Unit): BindingIdentifier =
    BindingIdentifierImpl().apply(block)

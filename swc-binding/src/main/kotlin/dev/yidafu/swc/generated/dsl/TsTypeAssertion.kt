// Auto-generated file. Do not edit. Generated at: 2025-11-20T00:09:39.394244

package dev.yidafu.swc.generated.dsl

import dev.yidafu.swc.generated.ArrayExpression
import dev.yidafu.swc.generated.ArrowFunctionExpression
import dev.yidafu.swc.generated.AssignmentExpression
import dev.yidafu.swc.generated.AwaitExpression
import dev.yidafu.swc.generated.BigIntLiteral
import dev.yidafu.swc.generated.BinaryExpression
import dev.yidafu.swc.generated.BooleanLiteral
import dev.yidafu.swc.generated.CallExpression
import dev.yidafu.swc.generated.ClassExpression
import dev.yidafu.swc.generated.ConditionalExpression
import dev.yidafu.swc.generated.FunctionExpression
import dev.yidafu.swc.generated.Identifier
import dev.yidafu.swc.generated.IdentifierImpl
import dev.yidafu.swc.generated.Invalid
import dev.yidafu.swc.generated.JSXElement
import dev.yidafu.swc.generated.JSXEmptyExpression
import dev.yidafu.swc.generated.JSXFragment
import dev.yidafu.swc.generated.JSXMemberExpression
import dev.yidafu.swc.generated.JSXNamespacedName
import dev.yidafu.swc.generated.JSXText
import dev.yidafu.swc.generated.MemberExpression
import dev.yidafu.swc.generated.MetaProperty
import dev.yidafu.swc.generated.NewExpression
import dev.yidafu.swc.generated.NullLiteral
import dev.yidafu.swc.generated.NumericLiteral
import dev.yidafu.swc.generated.ObjectExpression
import dev.yidafu.swc.generated.OptionalChainingExpression
import dev.yidafu.swc.generated.ParenthesisExpression
import dev.yidafu.swc.generated.PrivateName
import dev.yidafu.swc.generated.RegExpLiteral
import dev.yidafu.swc.generated.SequenceExpression
import dev.yidafu.swc.generated.StringLiteral
import dev.yidafu.swc.generated.SuperPropExpression
import dev.yidafu.swc.generated.TaggedTemplateExpression
import dev.yidafu.swc.generated.TemplateLiteral
import dev.yidafu.swc.generated.TemplateLiteralImpl
import dev.yidafu.swc.generated.ThisExpression
import dev.yidafu.swc.generated.TsArrayType
import dev.yidafu.swc.generated.TsAsExpression
import dev.yidafu.swc.generated.TsConditionalType
import dev.yidafu.swc.generated.TsConstAssertion
import dev.yidafu.swc.generated.TsConstructorType
import dev.yidafu.swc.generated.TsFunctionType
import dev.yidafu.swc.generated.TsImportType
import dev.yidafu.swc.generated.TsIndexedAccessType
import dev.yidafu.swc.generated.TsInferType
import dev.yidafu.swc.generated.TsInstantiation
import dev.yidafu.swc.generated.TsIntersectionType
import dev.yidafu.swc.generated.TsKeywordType
import dev.yidafu.swc.generated.TsLiteralType
import dev.yidafu.swc.generated.TsMappedType
import dev.yidafu.swc.generated.TsNonNullExpression
import dev.yidafu.swc.generated.TsOptionalType
import dev.yidafu.swc.generated.TsParenthesizedType
import dev.yidafu.swc.generated.TsRestType
import dev.yidafu.swc.generated.TsSatisfiesExpression
import dev.yidafu.swc.generated.TsThisType
import dev.yidafu.swc.generated.TsTupleType
import dev.yidafu.swc.generated.TsTypeAssertion
import dev.yidafu.swc.generated.TsTypeLiteral
import dev.yidafu.swc.generated.TsTypeOperator
import dev.yidafu.swc.generated.TsTypePredicate
import dev.yidafu.swc.generated.TsTypeQuery
import dev.yidafu.swc.generated.TsTypeReference
import dev.yidafu.swc.generated.TsUnionType
import dev.yidafu.swc.generated.UnaryExpression
import dev.yidafu.swc.generated.UpdateExpression
import dev.yidafu.swc.generated.YieldExpression
import kotlin.Unit

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> OptionalChainingExpression
 */
public fun TsTypeAssertion.optionalChainingExpression(block: OptionalChainingExpression.() -> Unit):
    OptionalChainingExpression = OptionalChainingExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ThisExpression
 */
public fun TsTypeAssertion.thisExpression(block: ThisExpression.() -> Unit): ThisExpression =
    ThisExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ArrayExpression
 */
public fun TsTypeAssertion.arrayExpression(block: ArrayExpression.() -> Unit): ArrayExpression =
    ArrayExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ObjectExpression
 */
public fun TsTypeAssertion.objectExpression(block: ObjectExpression.() -> Unit): ObjectExpression =
    ObjectExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> UnaryExpression
 */
public fun TsTypeAssertion.unaryExpression(block: UnaryExpression.() -> Unit): UnaryExpression =
    UnaryExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> UpdateExpression
 */
public fun TsTypeAssertion.updateExpression(block: UpdateExpression.() -> Unit): UpdateExpression =
    UpdateExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> BinaryExpression
 */
public fun TsTypeAssertion.binaryExpression(block: BinaryExpression.() -> Unit): BinaryExpression =
    BinaryExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> FunctionExpression
 */
public fun TsTypeAssertion.functionExpression(block: FunctionExpression.() -> Unit):
    FunctionExpression = FunctionExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ClassExpression
 */
public fun TsTypeAssertion.classExpression(block: ClassExpression.() -> Unit): ClassExpression =
    ClassExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> AssignmentExpression
 */
public fun TsTypeAssertion.assignmentExpression(block: AssignmentExpression.() -> Unit):
    AssignmentExpression = AssignmentExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> MemberExpression
 */
public fun TsTypeAssertion.memberExpression(block: MemberExpression.() -> Unit): MemberExpression =
    MemberExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> SuperPropExpression
 */
public fun TsTypeAssertion.superPropExpression(block: SuperPropExpression.() -> Unit):
    SuperPropExpression = SuperPropExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ConditionalExpression
 */
public fun TsTypeAssertion.conditionalExpression(block: ConditionalExpression.() -> Unit):
    ConditionalExpression = ConditionalExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> CallExpression
 */
public fun TsTypeAssertion.callExpression(block: CallExpression.() -> Unit): CallExpression =
    CallExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> NewExpression
 */
public fun TsTypeAssertion.newExpression(block: NewExpression.() -> Unit): NewExpression =
    NewExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> SequenceExpression
 */
public fun TsTypeAssertion.sequenceExpression(block: SequenceExpression.() -> Unit):
    SequenceExpression = SequenceExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ArrowFunctionExpression
 */
public fun TsTypeAssertion.arrowFunctionExpression(block: ArrowFunctionExpression.() -> Unit):
    ArrowFunctionExpression = ArrowFunctionExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> YieldExpression
 */
public fun TsTypeAssertion.yieldExpression(block: YieldExpression.() -> Unit): YieldExpression =
    YieldExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> MetaProperty
 */
public fun TsTypeAssertion.metaProperty(block: MetaProperty.() -> Unit): MetaProperty =
    MetaProperty().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> AwaitExpression
 */
public fun TsTypeAssertion.awaitExpression(block: AwaitExpression.() -> Unit): AwaitExpression =
    AwaitExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TaggedTemplateExpression
 */
public fun TsTypeAssertion.taggedTemplateExpression(block: TaggedTemplateExpression.() -> Unit):
    TaggedTemplateExpression = TaggedTemplateExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> ParenthesisExpression
 */
public fun TsTypeAssertion.parenthesisExpression(block: ParenthesisExpression.() -> Unit):
    ParenthesisExpression = ParenthesisExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> PrivateName
 */
public fun TsTypeAssertion.privateName(block: PrivateName.() -> Unit): PrivateName =
    PrivateName().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> JSXMemberExpression
 */
public fun TsTypeAssertion.jSXMemberExpression(block: JSXMemberExpression.() -> Unit):
    JSXMemberExpression = JSXMemberExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> JSXNamespacedName
 */
public fun TsTypeAssertion.jSXNamespacedName(block: JSXNamespacedName.() -> Unit): JSXNamespacedName
    = JSXNamespacedName().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> JSXEmptyExpression
 */
public fun TsTypeAssertion.jSXEmptyExpression(block: JSXEmptyExpression.() -> Unit):
    JSXEmptyExpression = JSXEmptyExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> JSXElement
 */
public fun TsTypeAssertion.jSXElement(block: JSXElement.() -> Unit): JSXElement =
    JSXElement().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> JSXFragment
 */
public fun TsTypeAssertion.jSXFragment(block: JSXFragment.() -> Unit): JSXFragment =
    JSXFragment().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TsAsExpression
 */
public fun TsTypeAssertion.tsAsExpression(block: TsAsExpression.() -> Unit): TsAsExpression =
    TsAsExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TsSatisfiesExpression
 */
public fun TsTypeAssertion.tsSatisfiesExpression(block: TsSatisfiesExpression.() -> Unit):
    TsSatisfiesExpression = TsSatisfiesExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TsInstantiation
 */
public fun TsTypeAssertion.tsInstantiation(block: TsInstantiation.() -> Unit): TsInstantiation =
    TsInstantiation().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TsConstAssertion
 */
public fun TsTypeAssertion.tsConstAssertion(block: TsConstAssertion.() -> Unit): TsConstAssertion =
    TsConstAssertion().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TsNonNullExpression
 */
public fun TsTypeAssertion.tsNonNullExpression(block: TsNonNullExpression.() -> Unit):
    TsNonNullExpression = TsNonNullExpression().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> Invalid
 */
public fun TsTypeAssertion.invalid(block: Invalid.() -> Unit): Invalid = Invalid().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> JSXText
 */
public fun TsTypeAssertion.jSXText(block: JSXText.() -> Unit): JSXText = JSXText().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> StringLiteral
 */
public fun TsTypeAssertion.stringLiteral(block: StringLiteral.() -> Unit): StringLiteral =
    StringLiteral().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> BooleanLiteral
 */
public fun TsTypeAssertion.booleanLiteral(block: BooleanLiteral.() -> Unit): BooleanLiteral =
    BooleanLiteral().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> NullLiteral
 */
public fun TsTypeAssertion.nullLiteral(block: NullLiteral.() -> Unit): NullLiteral =
    NullLiteral().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> RegExpLiteral
 */
public fun TsTypeAssertion.regExpLiteral(block: RegExpLiteral.() -> Unit): RegExpLiteral =
    RegExpLiteral().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> NumericLiteral
 */
public fun TsTypeAssertion.numericLiteral(block: NumericLiteral.() -> Unit): NumericLiteral =
    NumericLiteral().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> BigIntLiteral
 */
public fun TsTypeAssertion.bigIntLiteral(block: BigIntLiteral.() -> Unit): BigIntLiteral =
    BigIntLiteral().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> Identifier
 */
public fun TsTypeAssertion.identifier(block: Identifier.() -> Unit): Identifier =
    IdentifierImpl().apply(block)

/**
 * TsTypeAssertion#expression: Expression?
 * extension function for create Expression? -> TemplateLiteral
 */
public fun TsTypeAssertion.templateLiteral(block: TemplateLiteral.() -> Unit): TemplateLiteral =
    TemplateLiteralImpl().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsKeywordType
 */
public fun TsTypeAssertion.tsKeywordType(block: TsKeywordType.() -> Unit): TsKeywordType =
    TsKeywordType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsThisType
 */
public fun TsTypeAssertion.tsThisType(block: TsThisType.() -> Unit): TsThisType =
    TsThisType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsTypeReference
 */
public fun TsTypeAssertion.tsTypeReference(block: TsTypeReference.() -> Unit): TsTypeReference =
    TsTypeReference().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsTypePredicate
 */
public fun TsTypeAssertion.tsTypePredicate(block: TsTypePredicate.() -> Unit): TsTypePredicate =
    TsTypePredicate().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsImportType
 */
public fun TsTypeAssertion.tsImportType(block: TsImportType.() -> Unit): TsImportType =
    TsImportType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsTypeQuery
 */
public fun TsTypeAssertion.tsTypeQuery(block: TsTypeQuery.() -> Unit): TsTypeQuery =
    TsTypeQuery().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsTypeLiteral
 */
public fun TsTypeAssertion.tsTypeLiteral(block: TsTypeLiteral.() -> Unit): TsTypeLiteral =
    TsTypeLiteral().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsArrayType
 */
public fun TsTypeAssertion.tsArrayType(block: TsArrayType.() -> Unit): TsArrayType =
    TsArrayType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsTupleType
 */
public fun TsTypeAssertion.tsTupleType(block: TsTupleType.() -> Unit): TsTupleType =
    TsTupleType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsOptionalType
 */
public fun TsTypeAssertion.tsOptionalType(block: TsOptionalType.() -> Unit): TsOptionalType =
    TsOptionalType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsRestType
 */
public fun TsTypeAssertion.tsRestType(block: TsRestType.() -> Unit): TsRestType =
    TsRestType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsConditionalType
 */
public fun TsTypeAssertion.tsConditionalType(block: TsConditionalType.() -> Unit): TsConditionalType
    = TsConditionalType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsInferType
 */
public fun TsTypeAssertion.tsInferType(block: TsInferType.() -> Unit): TsInferType =
    TsInferType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsParenthesizedType
 */
public fun TsTypeAssertion.tsParenthesizedType(block: TsParenthesizedType.() -> Unit):
    TsParenthesizedType = TsParenthesizedType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsTypeOperator
 */
public fun TsTypeAssertion.tsTypeOperator(block: TsTypeOperator.() -> Unit): TsTypeOperator =
    TsTypeOperator().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsIndexedAccessType
 */
public fun TsTypeAssertion.tsIndexedAccessType(block: TsIndexedAccessType.() -> Unit):
    TsIndexedAccessType = TsIndexedAccessType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsMappedType
 */
public fun TsTypeAssertion.tsMappedType(block: TsMappedType.() -> Unit): TsMappedType =
    TsMappedType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsLiteralType
 */
public fun TsTypeAssertion.tsLiteralType(block: TsLiteralType.() -> Unit): TsLiteralType =
    TsLiteralType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsFunctionType
 */
public fun TsTypeAssertion.tsFunctionType(block: TsFunctionType.() -> Unit): TsFunctionType =
    TsFunctionType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsConstructorType
 */
public fun TsTypeAssertion.tsConstructorType(block: TsConstructorType.() -> Unit): TsConstructorType
    = TsConstructorType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsUnionType
 */
public fun TsTypeAssertion.tsUnionType(block: TsUnionType.() -> Unit): TsUnionType =
    TsUnionType().apply(block)

/**
 * TsTypeAssertion#typeAnnotation: TsType?
 * extension function for create TsType? -> TsIntersectionType
 */
public fun TsTypeAssertion.tsIntersectionType(block: TsIntersectionType.() -> Unit):
    TsIntersectionType = TsIntersectionType().apply(block)

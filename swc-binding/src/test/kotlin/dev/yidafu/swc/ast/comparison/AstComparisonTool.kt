package dev.yidafu.swc.ast.comparison

import dev.yidafu.swc.SwcNative
import dev.yidafu.swc.configJson
import dev.yidafu.swc.generated.*
import dev.yidafu.swc.generated.dsl.* // ktlint-disable no-wildcard-imports
import dev.yidafu.swc.util.NodeJsHelper
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.*
import java.io.File

/**
 * Utility class: Compare AST JSON generated by SwcNative and @swc/core to find issues in Kotlin AST class definitions
 */
object AstComparisonTool {

    /**
     * Comparison result data class
     */
    data class ComparisonResult(
        val kotlinJson: String,
        val swcJson: String,
        val differences: List<Difference>,
        val areEqual: Boolean
    )

    /**
     * Difference information
     */
    data class Difference(
        val path: String,
        val type: DifferenceType,
        val kotlinValue: String?,
        val swcValue: String?,
        val message: String
    )

    enum class DifferenceType {
        MISSING_IN_KOTLIN, // Field missing in Kotlin
        MISSING_IN_SWC, // Field missing in @swc/core
        VALUE_MISMATCH, // Value mismatch
        TYPE_MISMATCH, // Type mismatch
        ARRAY_LENGTH_MISMATCH // Array length mismatch
    }

    /**
     * Execute comparison analysis
     */
    fun compareAst(
        code: String,
        options: ParserConfig,
        swcNative: SwcNative,
        testName: String = "test"
    ): ComparisonResult {
        // Check if Node.js is available
        if (!NodeJsHelper.isNodeJsAvailable()) {
            throw IllegalStateException("Node.js is not available. Cannot compare with @swc/core.")
        }

        // 1. Get raw JSON from Kotlin (SwcNative)
        val optStr = configJson.encodeToString<ParserConfig>(options)
        val kotlinRawJson = try {
            swcNative.parseSync(code, optStr, "test.js")
        } catch (e: Exception) {
            throw IllegalStateException("Failed to parse code with SwcNative: ${e.message}", e)
        }

        if (kotlinRawJson.isBlank()) {
            throw IllegalStateException("SwcNative returned empty JSON")
        }

        // 2. Get JSON from @swc/core
        val swcOptionsJson = convertToSwcParseOptions(options)
        val swcRawJson = try {
            NodeJsHelper.parseCode(code, swcOptionsJson)
        } catch (e: Exception) {
            throw IllegalStateException("Failed to parse code with @swc/core: ${e.message}", e)
        }

        if (swcRawJson.isBlank()) {
            throw IllegalStateException("@swc/core returned empty JSON")
        }

        // 3. Parse JSON and compare
        val kotlinElement = Json.parseToJsonElement(kotlinRawJson)
        val swcElement = Json.parseToJsonElement(swcRawJson)

        val differences = mutableListOf<Difference>()
        compareElements(kotlinElement, swcElement, "", differences)

        // 4. Save JSON files for further analysis
        saveJsonFiles(testName, kotlinRawJson, swcRawJson)

        return ComparisonResult(
            kotlinJson = kotlinRawJson,
            swcJson = swcRawJson,
            differences = differences,
            areEqual = differences.isEmpty()
        )
    }

    /**
     * Recursively compare two JSON elements
     */
    private fun compareElements(
        kotlin: JsonElement,
        swc: JsonElement,
        path: String,
        differences: MutableList<Difference>
    ) {
        when {
            kotlin is JsonNull && swc is JsonNull -> {
                // Both are null, same
            }
            kotlin is JsonNull -> {
                differences.add(
                    Difference(
                        path = path,
                        type = DifferenceType.MISSING_IN_KOTLIN,
                        kotlinValue = null,
                        swcValue = swc.toString(),
                        message = "Kotlin is null, but @swc/core has value: $swc"
                    )
                )
            }
            swc is JsonNull -> {
                differences.add(
                    Difference(
                        path = path,
                        type = DifferenceType.MISSING_IN_SWC,
                        kotlinValue = kotlin.toString(),
                        swcValue = null,
                        message = "@swc/core is null, but Kotlin has value: $kotlin"
                    )
                )
            }
            kotlin is JsonPrimitive && swc is JsonPrimitive -> {
                if (!comparePrimitives(kotlin, swc)) {
                    differences.add(
                        Difference(
                            path = path,
                            type = DifferenceType.VALUE_MISMATCH,
                            kotlinValue = kotlin.toString(),
                            swcValue = swc.toString(),
                            message = "Value mismatch: Kotlin='$kotlin' vs @swc/core='$swc'"
                        )
                    )
                }
            }
            kotlin is JsonArray && swc is JsonArray -> {
                if (kotlin.size != swc.size) {
                    differences.add(
                        Difference(
                            path = path,
                            type = DifferenceType.ARRAY_LENGTH_MISMATCH,
                            kotlinValue = kotlin.size.toString(),
                            swcValue = swc.size.toString(),
                            message = "Array length mismatch: Kotlin=${kotlin.size} vs @swc/core=${swc.size}"
                        )
                    )
                }
                // Compare array elements
                val minSize = minOf(kotlin.size, swc.size)
                for (i in 0 until minSize) {
                    compareElements(kotlin[i], swc[i], "$path[$i]", differences)
                }
            }
            kotlin is JsonObject && swc is JsonObject -> {
                val allKeys = (kotlin.keys + swc.keys).distinct().sorted()

                for (key in allKeys) {
                    val newPath = if (path.isEmpty()) key else "$path.$key"
                    val kotlinValue = kotlin[key]
                    val swcValue = swc[key]

                    when {
                        kotlinValue == null && swcValue == null -> {
                            // Both missing, skip
                        }
                        kotlinValue == null -> {
                            differences.add(
                                Difference(
                                    path = newPath,
                                    type = DifferenceType.MISSING_IN_KOTLIN,
                                    kotlinValue = null,
                                    swcValue = swcValue.toString(),
                                    message = "Field '$key' missing in Kotlin AST, present in @swc/core: $swcValue"
                                )
                            )
                        }
                        swcValue == null -> {
                            differences.add(
                                Difference(
                                    path = newPath,
                                    type = DifferenceType.MISSING_IN_SWC,
                                    kotlinValue = kotlinValue.toString(),
                                    swcValue = null,
                                    message = "Field '$key' missing in @swc/core AST, present in Kotlin: $kotlinValue"
                                )
                            )
                        }
                        else -> {
                            compareElements(kotlinValue, swcValue, newPath, differences)
                        }
                    }
                }
            }
            else -> {
                differences.add(
                    Difference(
                        path = path,
                        type = DifferenceType.TYPE_MISMATCH,
                        kotlinValue = kotlin.toString(),
                        swcValue = swc.toString(),
                        message = "Type mismatch: Kotlin=${kotlin::class.simpleName} vs @swc/core=${swc::class.simpleName}"
                    )
                )
            }
        }
    }

    /**
     * Compare two primitive values
     */
    private fun comparePrimitives(p1: JsonPrimitive, p2: JsonPrimitive): Boolean {
        if (p1.isString && p2.isString) {
            return p1.content == p2.content
        }

        if (p1.isString || p2.isString) {
            return false
        }

        // Compare numbers
        val d1 = p1.doubleOrNull
        val d2 = p2.doubleOrNull
        if (d1 != null && d2 != null) {
            return kotlin.math.abs(d1 - d2) < 1e-10
        }

        // Compare booleans
        val b1 = p1.booleanOrNull
        val b2 = p2.booleanOrNull
        if (b1 != null && b2 != null) {
            return b1 == b2
        }

        return false
    }

    /**
     * Convert Kotlin ParserConfig to @swc/core parse options format
     */
    fun convertToSwcParseOptions(options: ParserConfig): String {
        fun getTargetName(target: JscTarget?): String {
            return target?.let {
                configJson.encodeToString(it).trim('"')
            } ?: "es5"
        }

        return when (options) {
            is EsParserConfig -> {
                val syntax = "ecmascript"
                val target = getTargetName(options.target)
                val isModule = true
                val comments = options.comments ?: false
                val script = options.script ?: false
                val jsx = options.jsx ?: false

                buildString {
                    append("""{"syntax":"$syntax","target":"$target","isModule":$isModule,"comments":$comments,"script":$script""")
                    if (jsx) append(""","jsx":true""")
                    append("}")
                }
            }
            is TsParserConfig -> {
                val syntax = "typescript"
                val target = getTargetName(options.target)
                val isModule = true
                val comments = options.comments ?: false
                val script = options.script ?: false
                val tsx = options.tsx ?: false
                val decorators = options.decorators ?: false

                buildString {
                    append("""{"syntax":"$syntax","target":"$target","isModule":$isModule,"comments":$comments,"script":$script""")
                    if (tsx) append(""","tsx":true""")
                    if (decorators) append(""","decorators":true""")
                    append("}")
                }
            }
            else -> """{"syntax":"ecmascript","target":"es5","isModule":true,"comments":false,"script":false}"""
        }
    }

    /**
     * Save JSON files to temporary directory
     */
    private fun saveJsonFiles(testName: String, kotlinJson: String, swcJson: String) {
        val outputDir = File("build/ast-comparison")
        outputDir.mkdirs()

        val kotlinFile = File(outputDir, "$testName-kotlin.json")
        val swcFile = File(outputDir, "$testName-swc.json")

        kotlinFile.writeText(kotlinJson)
        swcFile.writeText(swcJson)

        println("Saved JSON files:")
        println("  Kotlin: ${kotlinFile.absolutePath}")
        println("  @swc/core: ${swcFile.absolutePath}")
    }

    /**
     * Print comparison report
     */
    fun printReport(result: ComparisonResult) {
        println("=".repeat(80))
        println("AST JSON Comparison Report")
        println("=".repeat(80))

        if (result.areEqual) {
            println("✅ The two AST JSONs are identical!")
            return
        }

        println("\n❌ Found ${result.differences.size} differences:\n")

        // Group by type
        val byType = result.differences.groupBy { it.type }

        byType.forEach { (type, diffs) ->
            println("\n${"=".repeat(60)}")
            println("${type.name} (${diffs.size} items)")
            println("${"=".repeat(60)}")

            diffs.forEachIndexed { index, diff ->
                println("\nDifference #${index + 1}: ${diff.path}")
                println("  Type: ${diff.type}")
                println("  Message: ${diff.message}")
                if (diff.kotlinValue != null) {
                    println("  Kotlin value: ${diff.kotlinValue.take(200)}${if (diff.kotlinValue.length > 200) "..." else ""}")
                }
                if (diff.swcValue != null) {
                    println("  @swc/core value: ${diff.swcValue.take(200)}${if (diff.swcValue.length > 200) "..." else ""}")
                }
            }
        }

        // Analyze possible issues
        println("\n${"=".repeat(80)}")
        println("Issue Analysis")
        println("${"=".repeat(80)}")

        analyzeIssues(result.differences)

        println("\n${"=".repeat(80)}")
    }

    /**
     * Analyze differences to identify possible issues in Kotlin AST class definitions
     */
    private fun analyzeIssues(differences: List<Difference>) {
        val missingInKotlin = differences.filter { it.type == DifferenceType.MISSING_IN_KOTLIN }
        val missingInSwc = differences.filter { it.type == DifferenceType.MISSING_IN_SWC }
        val valueMismatches = differences.filter { it.type == DifferenceType.VALUE_MISMATCH }
        val typeMismatches = differences.filter { it.type == DifferenceType.TYPE_MISMATCH }

        if (missingInKotlin.isNotEmpty()) {
            println("\n⚠️  Possible missing fields in Kotlin AST class definitions:")
            missingInKotlin.take(20).forEach { diff ->
                val fieldPath = diff.path.split('.').lastOrNull() ?: diff.path
                println("  - $fieldPath (path: ${diff.path})")
            }
            if (missingInKotlin.size > 20) {
                println("  ... ${missingInKotlin.size - 20} more fields")
            }
        }

        if (missingInSwc.isNotEmpty()) {
            println("\n⚠️  Possible extra fields in Kotlin AST class definitions (not in @swc/core):")
            missingInSwc.take(20).forEach { diff ->
                val fieldPath = diff.path.split('.').lastOrNull() ?: diff.path
                println("  - $fieldPath (path: ${diff.path})")
            }
            if (missingInSwc.size > 20) {
                println("  ... ${missingInSwc.size - 20} more fields")
            }
        }

        if (typeMismatches.isNotEmpty()) {
            println("\n⚠️  Type mismatches (possibly serialization/deserialization issues):")
            typeMismatches.take(10).forEach { diff ->
                println("  - ${diff.path}: ${diff.message}")
            }
        }

        // Analyze common field name patterns
        val commonFields = listOf("span", "ctxt", "type", "loc", "range")
        val missingFields = missingInKotlin.map { it.path.split('.').lastOrNull() ?: "" }
            .filter { it in commonFields }

        if (missingFields.isNotEmpty()) {
            println("\n⚠️  Common fields missing:")
            missingFields.forEach { field ->
                println("  - $field (This is a standard SWC AST field and should exist in all nodes)")
            }
        }
    }
}

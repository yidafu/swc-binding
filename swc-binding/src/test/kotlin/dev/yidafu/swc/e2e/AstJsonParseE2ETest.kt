package dev.yidafu.swc.e2e

import dev.yidafu.swc.SwcNative
import dev.yidafu.swc.astJson
import dev.yidafu.swc.generated.*
import dev.yidafu.swc.generated.dsl.* // ktlint-disable no-wildcard-imports
import dev.yidafu.swc.util.JsonComparator
import io.kotest.core.annotation.Ignored
import io.kotest.core.spec.style.ShouldSpec
import io.kotest.matchers.shouldBe
import kotlinx.serialization.encodeToString
import java.io.InputStream

/**
 * E2E tests for parse method - comparing AST JSON from Kotlin and @swc/core
 * Uses pre-generated @swc/core parse results for comparison
 * 1. Use @swc/core to generate parse result AST JSON, save to resources/parse directory
 * 2. Kotlin test executes parse first, then reads AST JSON and compares with Kotlin parse code
 */
@Ignored
class AstJsonParseE2ETest : ShouldSpec({
    val swcNative = SwcNative()

    /**
     * Read pre-generated @swc/core parse results (AST JSON) from resources directory
     * These files are generated by generate-parse-resources.js script using @swc/core
     */
    fun readSwcParseResult(resourceName: String): String {
        val resourcePath = "parse/$resourceName.json"
        val inputStream: InputStream = AstJsonParseE2ETest::class.java.classLoader
            .getResourceAsStream(resourcePath)
            ?: throw IllegalStateException("Cannot find resource: $resourcePath")

        return inputStream.bufferedReader().use { it.readText() }
    }

    should("parse simple JavaScript variable declaration") {
        val code = "const x = 42;"
        val options = esParseOptions { }

        // Use Kotlin parse to process code
        val kotlinAst = swcNative.parseSync(code, options, "test.js")
        val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

        // Read pre-generated @swc/core parse result (AST JSON)
        val swcJson = readSwcParseResult("simple-javascript")

        // Compare Kotlin and @swc/core parse results
        val areEqual = JsonComparator.compare(kotlinJson, swcJson)
        if (!areEqual) {
            val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
            println("Differences found:")
            if (differences.isEmpty()) {
                println("  (No differences reported, but comparison returned false)")
                println("Kotlin JSON length: ${kotlinJson.length}")
                println("SWC JSON length: ${swcJson.length}")
            } else {
                differences.forEach { println("  - $it") }
            }
        }
        areEqual shouldBe true
    }

    should("parse JavaScript function") {
        val code = """
            function add(a, b) {
                return a + b;
            }
        """.trimIndent()
        val options = esParseOptions { }

        // Use Kotlin parse to process code
        val kotlinAst = swcNative.parseSync(code, options, "test.js")
        val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

        // Read pre-generated @swc/core parse result (AST JSON)
        val swcJson = readSwcParseResult("javascript-function")

        // Compare Kotlin and @swc/core parse results
        val areEqual = JsonComparator.compare(kotlinJson, swcJson)
        if (!areEqual) {
            val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
            println("Differences found:")
            differences.forEach { println("  - $it") }
        }
        areEqual shouldBe true
    }

    should("parse TypeScript interface") {
        val code = """
            interface User {
                name: string;
                age: number;
            }
        """.trimIndent()
        val options = tsParseOptions { }

        // Use Kotlin parse to process code
        val kotlinAst = swcNative.parseSync(code, options, "test.ts")
        val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

        // Read pre-generated @swc/core parse result (AST JSON)
        val swcJson = readSwcParseResult("typescript-interface")

        // Compare Kotlin and @swc/core parse results
        val areEqual = JsonComparator.compare(kotlinJson, swcJson)
        if (!areEqual) {
            val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
            println("Differences found:")
            differences.forEach { println("  - $it") }
        }
        areEqual shouldBe true
    }

    should("parse TypeScript class") {
        val code = """
            class Person {
                name: string;
                constructor(name: string) {
                    this.name = name;
                }
            }
        """.trimIndent()
        val options = tsParseOptions { }

        // Use Kotlin parse to process code
        val kotlinAst = swcNative.parseSync(code, options, "test.ts")
        val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

        // Read pre-generated @swc/core parse result (AST JSON)
        val swcJson = readSwcParseResult("typescript-class")

        // Compare Kotlin and @swc/core parse results
        val areEqual = JsonComparator.compare(kotlinJson, swcJson)
        if (!areEqual) {
            val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
            println("Differences found:")
            differences.forEach { println("  - $it") }
        }
        areEqual shouldBe true
    }

    should("parse JavaScript with comments") {
        val code = """
            // This is a comment
            const x = 42; // inline comment
        """.trimIndent()
        val options = esParseOptions {
            comments = true
        }

        // Use Kotlin parse to process code
        val kotlinAst = swcNative.parseSync(code, options, "test.js")
        val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

        // Read pre-generated @swc/core parse result (AST JSON)
        val swcJson = readSwcParseResult("javascript-with-comments")

        // Compare Kotlin and @swc/core parse results
        val areEqual = JsonComparator.compare(kotlinJson, swcJson)
        if (!areEqual) {
            val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
            println("Differences found:")
            differences.forEach { println("  - $it") }
        }
        areEqual shouldBe true
    }

    should("parse empty module") {
        val code = ""
        val options = esParseOptions { }

        // Use Kotlin parse to process code
        val kotlinAst = swcNative.parseSync(code, options, "test.js")
        val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

        // Read pre-generated @swc/core parse result (AST JSON)
        val swcJson = readSwcParseResult("empty-module")

        // Compare Kotlin and @swc/core parse results
        val areEqual = JsonComparator.compare(kotlinJson, swcJson)
        if (!areEqual) {
            val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
            println("Differences found:")
            differences.forEach { println("  - $it") }
        }
        areEqual shouldBe true
    }
})

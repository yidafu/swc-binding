package dev.yidafu.swc.e2e

import dev.yidafu.swc.SwcNative
import dev.yidafu.swc.Union
import dev.yidafu.swc.generated.*
import dev.yidafu.swc.generated.dsl.* // ktlint-disable no-wildcard-imports
import io.kotest.core.spec.style.ShouldSpec
import io.kotest.matchers.shouldBe
import java.io.InputStream

/**
 * E2E tests for minify method - comparing minified code from Kotlin and @swc/core
 * Uses pre-generated @swc/core minify results for comparison
 * 1. Use @swc/core to generate minify result code string, save to resources/minify directory
 * 2. Kotlin test reads JS code and compares with Kotlin minify code
 */
class AstJsonMinifyE2ETest : ShouldSpec({
    val swcNative = SwcNative()

    // Helper functions
    fun normalizeCode(code: String): String {
        return code
            .replace("\r\n", "\n")
            .replace("\r", "\n")
            .lines()
            .map { it.trim() }
            .filter { it.isNotEmpty() }
            .joinToString("\n")
            .trim()
    }

    /**
     * Read pre-generated @swc/core minify results (code string) from resources directory
     * These files are generated by generate-minify-resources.js script using @swc/core
     */
    fun readSwcMinifyResult(resourceName: String): String {
        val resourcePath = "minify/$resourceName.js"
        val inputStream: InputStream = AstJsonMinifyE2ETest::class.java.classLoader
            .getResourceAsStream(resourcePath)
            ?: throw IllegalStateException("Cannot find resource: $resourcePath")

        return inputStream.bufferedReader().use { it.readText() }
    }

    should("minify simple JavaScript code") {
        val code = """
            function add(a, b) {
                return a + b;
            }
        """.trimIndent()

        val minifyOptions = JsMinifyOptions().apply {
            compress = Union.U2<TerserCompressOptions, Boolean>(a = TerserCompressOptions())
            mangle = Union.U2<TerserMangleOptions, Boolean>(b = true)
        }

        // Use Kotlin minify to process code
        val kotlinOutput = swcNative.minifySync(code, minifyOptions)
        val kotlinCode = normalizeCode(kotlinOutput.code)

        // Read pre-generated @swc/core minify result (code string)
        val swcCode = normalizeCode(readSwcMinifyResult("simple-javascript"))

        // Compare Kotlin and @swc/core minify results
        kotlinCode shouldBe swcCode
    }

    should("minify JavaScript with variables") {
        val code = """
            const x = 42;
            const y = 100;
            const result = x + y;
        """.trimIndent()

        val minifyOptions = JsMinifyOptions().apply {
            compress = Union.U2<TerserCompressOptions, Boolean>(a = TerserCompressOptions())
            mangle = Union.U2<TerserMangleOptions, Boolean>(b = true)
        }

        // Use Kotlin minify to process code
        val kotlinOutput = swcNative.minifySync(code, minifyOptions)
        val kotlinCode = normalizeCode(kotlinOutput.code)

        // Read pre-generated @swc/core minify result (code string)
        val swcCode = normalizeCode(readSwcMinifyResult("javascript-with-variables"))

        // Compare Kotlin and @swc/core minify results
        kotlinCode shouldBe swcCode
    }

    should("minify TypeScript code") {
        val code = """
            interface User {
                name: string;
                age: number;
            }
            const user: User = { name: "John", age: 30 };
        """.trimIndent()

        val minifyOptions = JsMinifyOptions().apply {
            compress = Union.U2(a = TerserCompressOptions())
            mangle = Union.U2(b = true)
        }
        val res = swcNative.transformSync(
            code,
            options {
                jsc = jscConfig {
                    parser = tsParserConfig {
                        tsx = false
                    }
                    target = JscTarget.ES2020
                }
            }
        )
        // Note: TypeScript code needs to be converted to JavaScript first before minify
        // Here directly use TypeScript code, minify will convert first
        val kotlinOutput = swcNative.minifySync(res.code, minifyOptions)
        val kotlinCode = normalizeCode(kotlinOutput.code)

        // Read pre-generated @swc/core minify result (code string)
        // This result has been processed by transform + minify
        val swcCode = normalizeCode(readSwcMinifyResult("typescript-code"))

        // Compare Kotlin and @swc/core minify results
        kotlinCode shouldBe swcCode
    }

    should("minify with compress options") {
        val code = """
            function unused() {
                return 42;
            }
            function used() {
                return 100;
            }
            used();
        """.trimIndent()

        val minifyOptions = JsMinifyOptions().apply {
            compress = Union.U2<TerserCompressOptions, Boolean>(a = TerserCompressOptions())
            mangle = Union.U2<TerserMangleOptions, Boolean>(b = false)
        }

        // Use Kotlin minify to process code (compress only, no mangling)
        val kotlinOutput = swcNative.minifySync(code, minifyOptions)
        val kotlinCode = normalizeCode(kotlinOutput.code)

        // Read pre-generated @swc/core minify result (code string)
        val swcCode = normalizeCode(readSwcMinifyResult("compress-only"))

        // Compare Kotlin and @swc/core minify results
        kotlinCode shouldBe swcCode
    }
})

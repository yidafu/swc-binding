package dev.yidafu.swc

import dev.yidafu.swc.generated.*
import dev.yidafu.swc.generated.dsl.* // ktlint-disable no-wildcard-imports
import dev.yidafu.swc.util.JsonComparator
import dev.yidafu.swc.util.NodeJsHelper
import io.kotest.core.annotation.Ignored
import io.kotest.core.spec.style.ShouldSpec
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.*
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Systematically compare AST JSON generated by SwcNative and @swc/core to find issues in Kotlin AST class definitions
 * * This test will:
 * 1. Run multiple test cases
 * 2. Generate detailed difference reports
 * 3. Save JSON files for further analysis
 * 4. Statistics common difference patterns
 */
@Ignored
class AstJsonComparisonAnalysisTest : ShouldSpec({
    val swcNative = SwcNative()
    val outputDir = File("/tmp/swc-ast-comparison").apply { mkdirs() }
    val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"))
    val reportFile = File(outputDir, "comparison-report_$timestamp.txt")
    val report = StringBuilder()

    fun log(message: String) {
        println(message)
        report.appendLine(message)
    }

    /**
     * Convert Kotlin ParserConfig to @swc/core parse options format
     */
    fun convertToSwcParseOptions(options: ParserConfig): String {
        fun getTargetName(target: JscTarget?): String {
            return target?.let {
                configJson.encodeToString(it).trim('"')
            } ?: "es5"
        }

        return when (options) {
            is EsParserConfig -> {
                val syntax = "ecmascript"
                val target = getTargetName(options.target)
                val isModule = true
                val comments = options.comments ?: false
                val script = options.script ?: false
                val jsx = options.jsx ?: false

                buildString {
                    append("""{"syntax":"$syntax","target":"$target","isModule":$isModule,"comments":$comments,"script":$script""")
                    if (jsx) append(""","jsx":true""")
                    append("}")
                }
            }
            is TsParserConfig -> {
                val syntax = "typescript"
                val target = getTargetName(options.target)
                val isModule = true
                val comments = options.comments ?: false
                val script = options.script ?: false
                val tsx = options.tsx ?: false
                val decorators = options.decorators ?: false

                """{"syntax":"$syntax","target":"$target","isModule":$isModule,"comments":$comments,"script":$script,"tsx":$tsx,"decorators":$decorators}"""
            }
            else -> {
                """{"syntax":"ecmascript","target":"es5","isModule":true,"comments":false,"script":false}"""
            }
        }
    }

    fun collectSpans(element: JsonElement): List<String> {
        val spans = mutableListOf<String>()
        when (element) {
            is JsonObject -> {
                if (element.containsKey("span")) {
                    spans.add(element["span"].toString())
                }
                element.values.forEach { collectSpans(it).forEach { spans.add(it) } }
            }
            is JsonArray -> {
                element.forEach { collectSpans(it).forEach { spans.add(it) } }
            }
            is JsonPrimitive -> { /* ignore */ }
            is JsonNull -> { /* ignore */ }
        }
        return spans
    }

    fun collectCtxts(element: JsonElement): List<Int> {
        val ctxts = mutableListOf<Int>()
        when (element) {
            is JsonObject -> {
                if (element.containsKey("ctxt")) {
                    element["ctxt"]?.let {
                        if (it is JsonPrimitive) {
                            it.longOrNull?.toInt()?.let { ctxts.add(it) }
                        }
                    }
                }
                element.values.forEach { collectCtxts(it).forEach { ctxts.add(it) } }
            }
            is JsonArray -> {
                element.forEach { collectCtxts(it).forEach { ctxts.add(it) } }
            }
            is JsonPrimitive -> { /* ignore */ }
            is JsonNull -> { /* ignore */ }
        }
        return ctxts
    }

    fun collectTypes(element: JsonElement): List<String> {
        val types = mutableListOf<String>()
        when (element) {
            is JsonObject -> {
                if (element.containsKey("type")) {
                    element["type"]?.let {
                        if (it is JsonPrimitive && it.isString) {
                            types.add(it.content)
                        }
                    }
                }
                element.values.forEach { collectTypes(it).forEach { types.add(it) } }
            }
            is JsonArray -> {
                element.forEach { collectTypes(it).forEach { types.add(it) } }
            }
            is JsonPrimitive -> { /* ignore */ }
            is JsonNull -> { /* ignore */ }
        }
        return types
    }

    fun checkNullVsMissing(kotlinElement: JsonElement, swcElement: JsonElement) {
        // Check if there are fields that are null in Kotlin but missing in SWC
        // or vice versa
        // This requires recursive comparison, skip detailed implementation for now
    }

    fun countNodes(element: JsonElement): Int {
        var count = 0
        when (element) {
            is JsonObject -> {
                if (element.containsKey("type")) {
                    count++
                }
                element.values.forEach { count += countNodes(it) }
            }
            is JsonArray -> {
                element.forEach { count += countNodes(it) }
            }
            is JsonPrimitive -> { /* ignore */ }
            is JsonNull -> { /* ignore */ }
        }
        return count
    }

    /**
     * Check common issues
     */
    fun checkCommonIssues(kotlinElement: JsonElement, swcElement: JsonElement) {
        log("\nCommon Issues Check:")

        // Check span fields
        val kotlinSpans = collectSpans(kotlinElement)
        val swcSpans = collectSpans(swcElement)
        log("  Span count: Kotlin=${kotlinSpans.size}, SWC=${swcSpans.size}")

        // Check ctxt fields
        val kotlinCtxts = collectCtxts(kotlinElement)
        val swcCtxts = collectCtxts(swcElement)
        log("  Ctxt count: Kotlin=${kotlinCtxts.size}, SWC=${swcCtxts.size}")

        // Check type fields
        val kotlinTypes = collectTypes(kotlinElement)
        val swcTypes = collectTypes(swcElement)
        log("  Type field count: Kotlin=${kotlinTypes.size}, SWC=${swcTypes.size}")

        // Check for null vs missing field issues
        checkNullVsMissing(kotlinElement, swcElement)
    }

    /**
     * Analyze difference patterns
     */
    fun analyzeDifferences(kotlinJson: String, swcJson: String, differences: List<String>) {
        log("\nDifference Pattern Analysis:")

        val kotlinElement = Json.parseToJsonElement(kotlinJson)
        val swcElement = Json.parseToJsonElement(swcJson)

        // Statistics missing fields
        val missingInKotlin = mutableListOf<String>()
        val missingInSwc = mutableListOf<String>()
        val typeMismatches = mutableListOf<String>()
        val valueDifferences = mutableListOf<String>()

        differences.forEach { diff ->
            when {
                diff.contains("missing in first JSON") -> {
                    val field = diff.substringBefore(": missing")
                    missingInKotlin.add(field)
                }
                diff.contains("missing in second JSON") -> {
                    val field = diff.substringBefore(": missing")
                    missingInSwc.add(field)
                }
                diff.contains("type mismatch") -> {
                    typeMismatches.add(diff)
                }
                diff.contains("values differ") -> {
                    valueDifferences.add(diff)
                }
            }
        }

        if (missingInKotlin.isNotEmpty()) {
            log("\n  Fields missing in Kotlin (${missingInKotlin.size}):")
            missingInKotlin.take(20).forEach { log("    - $it") }
            if (missingInKotlin.size > 20) {
                log("    ... ${missingInKotlin.size - 20} more")
            }
        }

        if (missingInSwc.isNotEmpty()) {
            log("\n  Fields missing in SWC (${missingInSwc.size}):")
            missingInSwc.take(20).forEach { log("    - $it") }
            if (missingInSwc.size > 20) {
                log("    ... ${missingInSwc.size - 20} more")
            }
        }

        if (typeMismatches.isNotEmpty()) {
            log("\n  Type mismatches (${typeMismatches.size}):")
            typeMismatches.take(10).forEach { log("    - $it") }
            if (typeMismatches.size > 10) {
                log("    ... ${typeMismatches.size - 10} more")
            }
        }

        if (valueDifferences.isNotEmpty()) {
            log("\n  Value differences (${valueDifferences.size}):")
            valueDifferences.take(10).forEach { log("    - $it") }
            if (valueDifferences.size > 10) {
                log("    ... ${valueDifferences.size - 10} more")
            }
        }

        // Check common issues
        checkCommonIssues(kotlinElement, swcElement)
    }

    /**
     * Compare two JSONs and generate detailed report
     */
    fun compareAndAnalyze(
        testName: String,
        code: String,
        options: ParserConfig,
        filename: String
    ) {
        if (!NodeJsHelper.isNodeJsAvailable()) {
            log("⚠️  Node.js is not available, skipping test: $testName")
            return
        }

        log("\n${"=".repeat(80)}")
        log("Test Case: $testName")
        log("${"=".repeat(80)}")
        log("Code:\n$code")
        log("")

        try {
            // Get Kotlin AST JSON
            val kotlinAst = swcNative.parseSync(code, options, filename)
            val kotlinJson = astJson.encodeToString<Program>(kotlinAst)

            // Get @swc/core AST JSON
            val swcOptionsJson = convertToSwcParseOptions(options)
            val swcJson = NodeJsHelper.parseCode(code, swcOptionsJson)

            // Save JSON files
            val kotlinJsonFile = File(outputDir, "${testName}_kotlin_$timestamp.json")
            val swcJsonFile = File(outputDir, "${testName}_swc_$timestamp.json")
            kotlinJsonFile.writeText(kotlinJson)
            swcJsonFile.writeText(swcJson)
            log("Saved JSON files:")
            log("  Kotlin: ${kotlinJsonFile.absolutePath}")
            log("  SWC:    ${swcJsonFile.absolutePath}")

            // Compare JSON
            val areEqual = JsonComparator.compare(kotlinJson, swcJson)

            if (areEqual) {
                log("✅ JSONs match exactly")
            } else {
                log("❌ JSONs have differences")

                // Get detailed differences
                val differences = JsonComparator.getDifferences(kotlinJson, swcJson)
                log("\nDifference details (${differences.size} items):")
                differences.forEachIndexed { index, diff ->
                    log("  ${index + 1}. $diff")
                }

                // Analyze difference patterns
                analyzeDifferences(kotlinJson, swcJson, differences)
            }

            // Basic statistics
            val kotlinElement = Json.parseToJsonElement(kotlinJson)
            val swcElement = Json.parseToJsonElement(swcJson)
            log("\nBasic Statistics:")
            log("  Kotlin JSON size: ${kotlinJson.length} characters")
            log("  SWC JSON size:   ${swcJson.length} characters")
            log("  Kotlin node count:   ${countNodes(kotlinElement)}")
            log("  SWC node count:      ${countNodes(swcElement)}")
        } catch (e: Exception) {
            log("❌ Error: ${e.message}")
            e.printStackTrace()
        }
    }

    // Test cases
    context("AST JSON Comparison Analysis") {
        should("Simple variable declaration") {
            compareAndAnalyze(
                "simple-var-decl",
                "const x = 42;",
                esParseOptions { },
                "test.js"
            )
        }

        should("Function declaration") {
            compareAndAnalyze(
                "function-decl",
                """
                function add(a, b) {
                    return a + b;
                }
                """.trimIndent(),
                esParseOptions { },
                "test.js"
            )
        }

        should("JSX element") {
            compareAndAnalyze(
                "jsx-element",
                """
                function App() {
                    return <div>Hello</div>;
                }
                """.trimIndent(),
                esParseOptions {
                    jsx = true
                },
                "test.jsx"
            )
        }

        should("TypeScript interface") {
            compareAndAnalyze(
                "ts-interface",
                """
                interface User {
                    name: string;
                    age: number;
                }
                """.trimIndent(),
                tsParseOptions { },
                "test.ts"
            )
        }

        should("TypeScript class") {
            compareAndAnalyze(
                "ts-class",
                """
                class Person {
                    name: string;
                    constructor(name: string) {
                        this.name = name;
                    }
                }
                """.trimIndent(),
                tsParseOptions { },
                "test.ts"
            )
        }

        should("Code with comments") {
            compareAndAnalyze(
                "with-comments",
                """
                // This is a comment
                const x = 42; // inline comment
                """.trimIndent(),
                esParseOptions {
                    comments = true
                },
                "test.js"
            )
        }

        should("Complex JSX") {
            compareAndAnalyze(
                "complex-jsx",
                """
                function App() {
                    const show = true;
                    return (
                        <div>
                            {show && <p>Visible</p>}
                            {show ? <span>Yes</span> : <span>No</span>}
                        </div>
                    );
                }
                """.trimIndent(),
                esParseOptions {
                    jsx = true
                },
                "test.jsx"
            )
        }

        should("Array and object") {
            compareAndAnalyze(
                "array-object",
                """
                const arr = [1, 2, 3];
                const obj = { a: 1, b: 2 };
                """.trimIndent(),
                esParseOptions { },
                "test.js"
            )
        }

        should("Empty module") {
            compareAndAnalyze(
                "empty-module",
                "",
                esParseOptions { },
                "test.js"
            )
        }
    }

    afterSpec {
        // Save report
        reportFile.writeText(report.toString())
        log("\n${"=".repeat(80)}")
        log("Report saved to: ${reportFile.absolutePath}")
        log("${"=".repeat(80)}")
    }
})

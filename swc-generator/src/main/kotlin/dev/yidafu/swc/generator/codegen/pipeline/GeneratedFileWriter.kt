package dev.yidafu.swc.generator.codegen.pipeline

import java.io.Closeable
import java.nio.file.Files
import java.nio.file.Path
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.concurrent.CompletableFuture
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.math.max

/**
 * 支持并发写入与自定义格式化函数的文件写入器。
 */
class GeneratedFileWriter(
    private val parallelism: Int = max(1, Runtime.getRuntime().availableProcessors()),
    private val defaultFormatter: (String, Path) -> String = { content, _ -> content }
) : Closeable {

    private val executor: ExecutorService = Executors.newFixedThreadPool(parallelism)

    fun write(
        files: Collection<GeneratedFile>,
        formatterOverride: ((String, Path) -> String)? = null
    ) {
        if (files.isEmpty()) return
        val formatter = formatterOverride ?: defaultFormatter
        val futures = files.map { file ->
            CompletableFuture.runAsync({
                writeSingleFile(file, formatter)
            }, executor)
        }
        futures.forEach { it.join() }
    }

    private fun writeSingleFile(
        file: GeneratedFile,
        formatter: (String, Path) -> String
    ) {
        val targetPath = file.outputPath
        targetPath.parent?.let { Files.createDirectories(it) }
        val content = file.buildContent()

        // 调试：检查 ForOfStatement 和 ComputedPropName
        val fileName = targetPath.fileName.toString()
        if (fileName == "ForOfStatement.kt" || fileName == "ComputedPropName.kt") {
            println("  [DEBUG] 写入文件: $fileName, 内容长度: ${content.length}")
            if (content.isEmpty()) {
                println("  [WARN] 文件内容为空: $fileName")
            }
        }

        val formatted = file.formatter?.invoke(content, targetPath) ?: formatter(content, targetPath)
        val finalContent = AutoGeneratedHeaderFormatter.ensureHeader(formatted)

        // 检查文件是否存在，如果存在则比较内容
        if (Files.exists(targetPath)) {
            val existingContent = Files.readString(targetPath)
            // 比较内容时忽略头部注释中的时间戳
            if (contentEqualsIgnoringHeaderTimestamp(existingContent, finalContent)) {
                // 内容相同，跳过写入
                if (fileName == "ForOfStatement.kt" || fileName == "ComputedPropName.kt") {
                    println("  [DEBUG] 文件内容相同，跳过写入: $fileName")
                }
                return
            } else {
                if (fileName == "ForOfStatement.kt" || fileName == "ComputedPropName.kt") {
                    println("  [DEBUG] 文件内容不同，将写入: $fileName")
                }
            }
        } else {
            if (fileName == "ForOfStatement.kt" || fileName == "ComputedPropName.kt") {
                println("  [DEBUG] 文件不存在，将创建: $fileName")
            }
        }

        Files.writeString(targetPath, finalContent)
        if (fileName == "ForOfStatement.kt" || fileName == "ComputedPropName.kt") {
            println("  [DEBUG] 文件写入完成: $fileName")
        }
    }

    /**
     * 比较两个文件内容是否相同，忽略头部注释中的时间戳和所有其他注释。
     * 头部注释格式: // Auto-generated file. Do not edit. Generated at: <timestamp>
     */
    private fun contentEqualsIgnoringHeaderTimestamp(existing: String, new: String): Boolean {
        val existingNormalized = normalizeContent(existing)
        val newNormalized = normalizeContent(new)
        return existingNormalized == newNormalized
    }

    /**
     * 标准化内容，移除头部注释中的时间戳部分，以及所有其他注释（包括单行注释、多行注释和 KDoc）。
     */
    private fun normalizeContent(content: String): String {
        // 首先移除头部注释
        val headerPrefix = "// Auto-generated file. Do not edit. Generated at: "
        val contentWithoutHeader = if (content.startsWith(headerPrefix)) {
            val firstNewlineIndex = content.indexOf('\n')
            if (firstNewlineIndex != -1) {
                val remainingContent = content.substring(firstNewlineIndex + 1)
                remainingContent.removePrefix("\n")
            } else {
                content
            }
        } else {
            content
        }
        
        // 移除所有注释（单行注释、多行注释和 KDoc）
        return removeAllComments(contentWithoutHeader)
    }

    /**
     * 移除 Kotlin 代码中的所有注释，但保留字符串字面量中的内容。
     * 支持：
     * - 单行注释：//
     * - 多行注释：/* */
     * - KDoc 注释：/** */
     */
    private fun removeAllComments(content: String): String {
        val result = StringBuilder()
        var i = 0
        val length = content.length
        
        while (i < length) {
            when {
                // 检查是否是原始字符串（三重引号）- 优先检查，因为可能包含普通引号
                i + 2 < length && content.substring(i, i + 3) == "\"\"\"" -> {
                    result.append("\"\"\"")
                    i += 3
                    // 跳过原始字符串内容
                    while (i + 2 < length) {
                        if (content.substring(i, i + 3) == "\"\"\"") {
                            result.append("\"\"\"")
                            i += 3
                            break
                        }
                        result.append(content[i])
                        i++
                    }
                }
                // 检查是否是字符串字面量（双引号）
                content[i] == '"' -> {
                    result.append(content[i])
                    i++
                    // 跳过字符串内容，直到找到未转义的结束引号
                    while (i < length) {
                        result.append(content[i])
                        if (content[i] == '"') {
                            // 检查是否是转义的引号（计算连续反斜杠的数量）
                            var backslashCount = 0
                            var j = i - 1
                            while (j >= 0 && content[j] == '\\') {
                                backslashCount++
                                j--
                            }
                            // 如果反斜杠数量是偶数，则引号未转义
                            if (backslashCount % 2 == 0) {
                                i++
                                break
                            }
                        }
                        i++
                    }
                }
                // 检查是否是单行注释
                i + 1 < length && content[i] == '/' && content[i + 1] == '/' -> {
                    // 跳过直到行尾
                    while (i < length && content[i] != '\n') {
                        i++
                    }
                    // 保留换行符
                    if (i < length) {
                        result.append(content[i])
                        i++
                    }
                }
                // 检查是否是多行注释或 KDoc
                i + 1 < length && content[i] == '/' && content[i + 1] == '*' -> {
                    val isKDoc = i + 2 < length && content[i + 2] == '*'
                    i += if (isKDoc) 3 else 2
                    // 跳过直到找到 */
                    while (i + 1 < length) {
                        if (content[i] == '*' && content[i + 1] == '/') {
                            i += 2
                            break
                        }
                        i++
                    }
                }
                // 普通字符
                else -> {
                    result.append(content[i])
                    i++
                }
            }
        }
        
        return result.toString()
    }

    override fun close() {
        executor.shutdown()
        try {
            // 等待所有任务完成，最多等待 30 秒
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow()
                // 再等待 10 秒以确保线程真正终止
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    System.err.println("线程池未能正常关闭")
                }
            }
        } catch (e: InterruptedException) {
            executor.shutdownNow()
            Thread.currentThread().interrupt()
        }
    }
}

/**
 * 自动生成文件头注释工具。
 */
object AutoGeneratedHeaderFormatter {
    private val dateFormatter: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME
    private const val HEADER_PREFIX = "// Auto-generated file. Do not edit. Generated at: "

    fun ensureHeader(content: String): String {
        if (content.startsWith(HEADER_PREFIX)) {
            return content
        }
        val header = buildHeader()
        val sanitizedContent = content.removePrefix("\n")
        return buildString(sanitizedContent.length + header.length + 2) {
            append(header)
            append('\n')
            append('\n')
            append(sanitizedContent)
        }
    }

    private fun buildHeader(date: LocalDateTime = LocalDateTime.now()): String {
        val dateText = date.format(dateFormatter)
        return HEADER_PREFIX + dateText
    }
}

package dev.yidafu.swc.generator.codegen.pipeline

import dev.yidafu.swc.generator.util.DebugUtils
import dev.yidafu.swc.generator.util.DebugUtils.isDebugType
import java.io.Closeable
import java.nio.file.Files
import java.nio.file.Path
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.concurrent.CompletableFuture
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.math.max

/**
 * 支持并发写入与自定义格式化函数的文件写入器。
 */
class GeneratedFileWriter(
    private val parallelism: Int = max(1, Runtime.getRuntime().availableProcessors()),
    private val defaultFormatter: (String, Path) -> String = { content, _ -> content }
) : Closeable {

    private val executor: ExecutorService = Executors.newFixedThreadPool(parallelism)

    fun write(
        files: Collection<GeneratedFile>,
        formatterOverride: ((String, Path) -> String)? = null
    ) {
        if (files.isEmpty()) return
        val formatter = formatterOverride ?: defaultFormatter
        val futures = files.map { file ->
            CompletableFuture.runAsync({
                writeSingleFile(file, formatter)
            }, executor)
        }
        futures.forEach { it.join() }
    }

    private fun writeSingleFile(
        file: GeneratedFile,
        formatter: (String, Path) -> String
    ) {
        val targetPath = file.outputPath
        targetPath.parent?.let { Files.createDirectories(it) }
        val content = file.buildContent()

        // 调试：检查调试类型
        val fileName = targetPath.fileName.toString()
        val baseFileName = fileName.removeSuffix(".kt")
        if (isDebugType(baseFileName)) {
            DebugUtils.debug("写入文件: $fileName, 内容长度: ${content.length}")
            if (content.isEmpty()) {
                DebugUtils.debug("文件内容为空: $fileName", "WARN")
            }
        }

        val formatted = file.formatter?.invoke(content, targetPath) ?: formatter(content, targetPath)
        val finalContent = AutoGeneratedHeaderFormatter.ensureHeader(formatted)

        // 检查文件是否存在，如果存在则比较内容
        if (Files.exists(targetPath)) {
            val existingContent = Files.readString(targetPath)
            // 比较内容时忽略头部注释中的时间戳
            if (contentEqualsIgnoringHeaderTimestamp(existingContent, finalContent)) {
                // 内容相同，跳过写入
                if (isDebugType(baseFileName)) {
                    DebugUtils.debug("文件内容相同，跳过写入: $fileName")
                }
                return
            } else {
                if (isDebugType(baseFileName)) {
                    DebugUtils.debug("文件内容不同，将写入: $fileName")
                }
            }
        } else {
            if (isDebugType(baseFileName)) {
                DebugUtils.debug("文件不存在，将创建: $fileName")
            }
        }

        Files.writeString(targetPath, finalContent)
        if (isDebugType(baseFileName)) {
            DebugUtils.debug("文件写入完成: $fileName")
        }
    }

    /**
     * 比较两个文件内容是否相同，仅忽略头部注释中的时间戳。
     * 头部注释格式: // Auto-generated file. Do not edit. Generated at: <timestamp>
     */
    private fun contentEqualsIgnoringHeaderTimestamp(existing: String, new: String): Boolean {
        val existingNormalized = normalizeContent(existing)
        val newNormalized = normalizeContent(new)
        return existingNormalized == newNormalized
    }

    /**
     * 标准化内容，仅移除头部注释（包含时间戳的那一行）及其后的空行。
     * 保留其他所有内容，包括其他注释。
     */
    private fun normalizeContent(content: String): String {
        // 移除头部注释（仅第一行的自动生成注释）
        val headerPrefix = "// Auto-generated file. Do not edit. Generated at: "
        return if (content.startsWith(headerPrefix)) {
            val firstNewlineIndex = content.indexOf('\n')
            if (firstNewlineIndex != -1) {
                var remainingContent = content.substring(firstNewlineIndex + 1)
                // 移除头部注释后的所有连续空行
                while (remainingContent.startsWith("\n")) {
                    remainingContent = remainingContent.substring(1)
                }
                remainingContent
            } else {
                // 如果整个文件只有头部注释，返回空字符串
                ""
            }
        } else {
            content
        }
    }

    override fun close() {
        executor.shutdown()
        try {
            // 等待所有任务完成，最多等待 30 秒
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow()
                // 再等待 10 秒以确保线程真正终止
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    System.err.println("线程池未能正常关闭")
                }
            }
        } catch (e: InterruptedException) {
            executor.shutdownNow()
            Thread.currentThread().interrupt()
        }
    }
}

/**
 * 自动生成文件头注释工具。
 */
object AutoGeneratedHeaderFormatter {
    private val dateFormatter: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME
    private const val HEADER_PREFIX = "// Auto-generated file. Do not edit. Generated at: "

    fun ensureHeader(content: String): String {
        if (content.startsWith(HEADER_PREFIX)) {
            return content
        }
        val header = buildHeader()
        val sanitizedContent = content.removePrefix("\n")
        return buildString(sanitizedContent.length + header.length + 2) {
            append(header)
            append('\n')
            append('\n')
            append(sanitizedContent)
        }
    }

    private fun buildHeader(date: LocalDateTime = LocalDateTime.now()): String {
        val dateText = date.format(dateFormatter)
        return HEADER_PREFIX + dateText
    }
}

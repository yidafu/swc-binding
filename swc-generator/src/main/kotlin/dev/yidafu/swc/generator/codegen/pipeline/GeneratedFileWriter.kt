package dev.yidafu.swc.generator.codegen.pipeline

import java.io.Closeable
import java.nio.file.Files
import java.nio.file.Path
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.concurrent.CompletableFuture
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.math.max

/**
 * 支持并发写入与自定义格式化函数的文件写入器。
 */
class GeneratedFileWriter(
    private val parallelism: Int = max(1, Runtime.getRuntime().availableProcessors()),
    private val defaultFormatter: (String, Path) -> String = { content, _ -> content }
) : Closeable {

    private val executor: ExecutorService = Executors.newFixedThreadPool(parallelism)

    fun write(
        files: Collection<GeneratedFile>,
        formatterOverride: ((String, Path) -> String)? = null
    ) {
        if (files.isEmpty()) return
        val formatter = formatterOverride ?: defaultFormatter
        val futures = files.map { file ->
            CompletableFuture.runAsync({
                writeSingleFile(file, formatter)
            }, executor)
        }
        futures.forEach { it.join() }
    }

    private fun writeSingleFile(
        file: GeneratedFile,
        formatter: (String, Path) -> String
    ) {
        val targetPath = file.outputPath
        targetPath.parent?.let { Files.createDirectories(it) }
        val content = file.buildContent()
        val formatted = file.formatter?.invoke(content, targetPath) ?: formatter(content, targetPath)
        val finalContent = AutoGeneratedHeaderFormatter.ensureHeader(formatted)
        Files.writeString(targetPath, finalContent)
    }

    override fun close() {
        executor.shutdown()
        try {
            // 等待所有任务完成，最多等待 30 秒
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow()
                // 再等待 10 秒以确保线程真正终止
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    System.err.println("线程池未能正常关闭")
                }
            }
        } catch (e: InterruptedException) {
            executor.shutdownNow()
            Thread.currentThread().interrupt()
        }
    }
}

/**
 * 自动生成文件头注释工具。
 */
object AutoGeneratedHeaderFormatter {
    private val dateFormatter: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME
    private const val HEADER_PREFIX = "// Auto-generated file. Do not edit. Generated at: "

    fun ensureHeader(content: String): String {
        if (content.startsWith(HEADER_PREFIX)) {
            return content
        }
        val header = buildHeader()
        val sanitizedContent = content.removePrefix("\n")
        return buildString(sanitizedContent.length + header.length + 2) {
            append(header)
            append('\n')
            append('\n')
            append(sanitizedContent)
        }
    }

    private fun buildHeader(date: LocalDateTime = LocalDateTime.now()): String {
        val dateText = date.format(dateFormatter)
        return HEADER_PREFIX + dateText
    }
}

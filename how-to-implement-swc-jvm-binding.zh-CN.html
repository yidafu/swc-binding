<!DOCTYPE html>
<html>
<head>
  <title>docs/how-to-implement-swc-jvm-binding.zh-CN.md</title>
  <link rel="stylesheet" href="theme.css">
</head>
<body><div class="markdown-body">
<h1 id="-swc-jvm-binding">如何实现 SWC JVM binding</h1>
<h2 id="-">背景</h2>
<p>在使用 Kotlin Jupiter Kennel 的过程中发现没有3D绘制库，只能使用 JS 来绘制数据。只能通过<code>HTML(...)</code>函数来写 JS，非常不方便。所以，我写了 <a href="https://github.com/yidafu/kotlin-jupyter-js">kotlin-jupyter-js</a> 插件来支持<code>%js</code> line magics。<code>kotlin-jupyter-js</code>插件的核心问题是：在 JVM 支持编译 JS 代码成 AST。为此需要一个工具将 JS 代码转换成 AST，最好还能支持 TS 和 JSX。</p>
<p>我的想法是实现 SWC 的 JVM binding 来解决这个问题。SWC 本身提供 Node 的 binding，所以 JVM binding 实现难度没有那么大。而且，SWC 支持 TS/JSX 编译，可以让<code>kotlin-jupyter-js</code>支持<code>typescript</code>和<code>React</code>。</p>
<h2 id="-">实现思路</h2>
<p>SWC JVM binding 实现了分成两部分。1. 将 SWC 的 Rust 代码编译成 JNI 动态库；2. JVM 侧，实现配置类和 AST 类。</p>
<p>SWC 是给 JS 使用的，只提供了支持 Node binding。我们需要参考 Node binding，来实现 JVM 的 binding。</p>
<p>SWC Node binding 暴露的 API 出参、入参都是 JSON 字符串，在 Node 里 JSON 字符串很容易转为对象，在 JVM 里则需要相应的类声明。</p>
<blockquote>
<p>SWC 提供了 WASM binding，可以基于 WASM 来封装 SWC，好处是不需要实现 JNI binding，但是需要额外引入 WASM Runtime。故没有考虑。</p>
</blockquote>
<h2 id="swc-binding">SWC binding</h2>
<h3 id="rust-jni-ffi">Rust JNI FFI</h3>
<p>将 Rust 编译成 JNI 动态库，需要 Rust 的 JNI FFI。直接使用 <a href="https://crates.io/crates/jni">jni</a> 即可支持。</p>
<p>这个库提供可以很方便地桥接 Rust 和 Java。可以看一下 <code>jni</code> 的官方例子。</p>
<p>在 JVM 侧代码。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span> <span class="p">{</span>
    <span class="n">init</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s">&quot;mylib&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">external</span> <span class="k">fun</span> <span class="nf">hello</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">String</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>在 Rust 代码只需要写一下胶水代码即可。</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="cp">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">&quot;system&quot;</span> <span class="k">fn</span> <span class="n">Java_HelloWorld_hello</span><span class="o">&lt;</span><span class="nl">&#39;local</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">env</span><span class="o">:</span> <span class="n">JNIEnv</span><span class="o">&lt;</span><span class="nl">&#39;local</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">class</span><span class="o">:</span> <span class="n">JClass</span><span class="o">&lt;</span><span class="nl">&#39;local</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">input</span><span class="o">:</span> <span class="n">JString</span><span class="o">&lt;</span><span class="nl">&#39;local</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jstring</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="n">input</span><span class="o">:</span> <span class="n">String</span> <span class="o">=</span>
        <span class="n">env</span><span class="p">.</span><span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t get java string!&quot;</span><span class="p">).</span><span class="n">into</span><span class="p">();</span>

    <span class="c1">// your business logic</span>
    <span class="kd">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="n">new_string</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}!&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">))</span>
        <span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create java string!&quot;</span><span class="p">);</span>

    <span class="n">output</span><span class="p">.</span><span class="n">into_raw</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>调用<code>HelloWorld().hello(&quot;JNI&quot;)</code>，通过 JNI 会调用Rust 代码返回<code>Hello, JNI!</code>.</p>
<p>上面 Rust 代码里桥接函数的申明比较长，可以使用 <a href="https://crates.io/crates/jni_fn">jni_fn</a> 通过宏自动生成桥接函数声明，简化声明。</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="cp">#[jni_fn(</span><span class="s">&quot;HelloWorld&quot;</span><span class="cp">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">hello</span><span class="o">&lt;</span><span class="nl">&#39;local</span><span class="o">&gt;</span><span class="p">(...)</span> <span class="o">-&gt;</span> <span class="n">jstring</span>
</pre></div>

</code></pre>
<p>通过 <code>jni</code> 和 <code>jni_fn</code> 我们可以将 Rust 代码编译成 JNI 动态库。</p>
<h3 id="binding">Binding</h3>
<p>SWC Node binding 提供了以下方法</p>
<ul>
<li>transform<ul>
<li>transform</li>
<li>transformSync</li>
<li>transformFile</li>
<li>transformFileSync</li>
</ul>
</li>
<li>parse<ul>
<li>parse</li>
<li>parseSync</li>
<li>parseFile</li>
<li>parseFileSync</li>
</ul>
</li>
<li>minify<ul>
<li>minify</li>
<li>minifySync</li>
</ul>
</li>
<li>print<ul>
<li>print</li>
<li>printSync</li>
</ul>
</li>
</ul>
<p>SWC Node binding 通过 <a href="https://crates.io/crates/napi">napi</a> 提供同步和异步方法。但是 JVM 的 FFI <code>jni</code> 并不只支持异步，所以我们只实现同步 API：<code>transformSync</code>,<code>transformFileSync</code>,<code>parseSync</code>,<code>parseFileSync</code>,<code>minifySync</code>,<code>printSync</code>。</p>
<h3 id="pase_sync">pase_sync</h3>
<p>下面以<code>pase_sync</code>为例，解释如何实现。</p>
<h4 id="-">依赖</h4>
<p>SWC 本身只考虑了 Node binding。<a href="https://crates.io/crates/swc_core">swc_core</a> 实现了与 Node 绑定的逻辑、聚合其他 SWC 子包依赖。NMP 包<code>@swc/core</code>也是封装<code>swc_core</code>。我们不能直接使用<code>swc_core</code>库，需要替换其他 SWC 子包调用。</p>
<p>比如，从<code>swc_core</code>引入<code>Compiler</code>：</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="kn">use</span> <span class="n">swc_core</span><span class="o">::</span><span class="p">{</span>
    <span class="n">base</span><span class="o">::</span><span class="p">{</span>
        <span class="n">Compiler</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>需要改为从 <a href="https://crates.io/crates/swc">swc</a> 引入。</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="kn">use</span> <span class="n">swc</span><span class="o">::</span><span class="n">Compiler</span><span class="p">;</span>
</pre></div>

</code></pre>
<p><code>swc_core</code>转换后的所有 SWC 相关依赖:</p>
<pre><code class="lang-ini"><div class="highlight"><pre><span class="k">[dependencies]</span>
<span class="c1"># ...</span>
<span class="na">swc</span> <span class="o">=</span> <span class="s">&quot;0.270.25&quot;</span>
<span class="na">swc_common</span> <span class="o">=</span> <span class="s">&quot;0.33.9&quot;</span>
<span class="na">swc_ecma_ast</span> <span class="o">=</span> <span class="s">{ version =&quot;0.110.10&quot;, features = [&quot;serde-impl&quot;] }</span>
<span class="na">swc_ecma_transforms</span> <span class="o">=</span> <span class="s">&quot;0.227.19&quot;</span>
<span class="na">swc_ecma_transforms_base</span> <span class="o">=</span> <span class="s">&quot;0.135.11&quot;</span>
<span class="na">swc_ecma_visit</span> <span class="o">=</span> <span class="s">&quot;0.96.10&quot;</span>
<span class="na">swc_ecma_codegen</span> <span class="o">=</span> <span class="s">&quot;0.146.39&quot;</span>
<span class="c1"># ...</span>
</pre></div>

</code></pre>
<h4 id="-">出入参</h4>
<p>理论上，需要做的工作很简单：将所有 <code>napi</code> 相关逻辑替换成<code>jni</code>即可。如何 SWC 如何实现具体功能，我们都不需要改动。</p>
<p>参考 <a href="https://github.com/swc-project/swc/tree/main/bindings/binding_core_node">SWC - binding_core_node</a> 的 <code>pase_sync</code> 实现 <a href="https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/bindings/binding_core_node/src/parse.rs#L168">binding_core_node/src/parse.rs#L168</a>, <code>parseSync</code> 大部分逻辑都直接复制，但需要修改入参、出参的处理。</p>
<p><code>binding_core_node</code> 的 <code>pase_sync</code> 实现：</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="cp">#[napi]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">parse_sync</span><span class="p">(</span><span class="n">src</span><span class="o">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">opts</span><span class="o">:</span> <span class="nb">Buffer</span><span class="p">,</span> <span class="n">filename</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">napi</span><span class="o">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>


    <span class="nb">Ok</span><span class="p">(</span><span class="n">serde_json</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">program</span><span class="p">)</span><span class="o">?</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>需要修改签名和出入参处理：</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="cp">#[jni_fn(</span><span class="s">&quot;dev.yidafu.swc.SwcNative&quot;</span><span class="cp">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">parseSync</span><span class="p">(</span><span class="k">mut</span> <span class="n">env</span><span class="o">:</span> <span class="n">JNIEnv</span><span class="p">,</span> <span class="n">_</span><span class="o">:</span> <span class="n">JClass</span><span class="p">,</span> <span class="n">code</span><span class="o">:</span> <span class="n">JString</span><span class="p">,</span> <span class="n">options</span><span class="o">:</span> <span class="n">JString</span><span class="p">,</span> <span class="n">filename</span><span class="o">:</span> <span class="n">JString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jstring</span> <span class="p">{</span>
    <span class="c1">// process parameter</span>
    <span class="kd">let</span> <span class="n">src</span><span class="o">:</span> <span class="n">String</span> <span class="o">=</span> <span class="n">env</span>
        <span class="p">.</span><span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code</span><span class="p">)</span>
        <span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t get java string!&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">into</span><span class="p">();</span>
    <span class="kd">let</span> <span class="n">opts</span><span class="o">:</span> <span class="n">String</span> <span class="o">=</span> <span class="n">env</span>
        <span class="p">.</span><span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">)</span>
        <span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t get java string!&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">into</span><span class="p">();</span>
    <span class="kd">let</span> <span class="n">filename</span><span class="o">:</span> <span class="n">String</span> <span class="o">=</span> <span class="n">env</span>
        <span class="p">.</span><span class="n">get_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filename</span><span class="p">)</span>
        <span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t get java string!&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">into</span><span class="p">();</span>

    <span class="c1">// ...</span>

    <span class="c1">// process return value</span>
    <span class="kd">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">env</span>
        <span class="p">.</span><span class="n">new_string</span><span class="p">(</span><span class="n">ast_json</span><span class="p">)</span>
        <span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create java string!&quot;</span><span class="p">);</span>

    <span class="n">output</span><span class="p">.</span><span class="n">into_raw</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>获取 JVM 传过来的字符串，需要调用<code>JNIEnv</code>的<code>get_string</code>。</p>
<p>将 Rust 字符串转为Java字符串也需要调用 <code>JNIEnv</code>的<code>new_string</code>在转为<code>jstring</code>类型。</p>
<h4 id="-">异常处理</h4>
<p>如果 SWC 处理 JS 代码失败了（比如JS代码有语法错误），需要抛出异常到 JVM，由 JVM 侧进行处理。</p>
<p>首先捕获 Rust 抛出的代码，再转换成 JVM 的异常抛出。</p>
<p><code>binding_core_node</code> 处理时对于<code>Result</code>实现了<code>MapErr&lt;T&gt;</code> trait,通过<code>convert_err</code> 方法��� Rust 异常转为了<code>napi</code>的异常，最后在 Node 里抛出。</p>
<p>SWC 的异常处理 <a href="https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/bindings/binding_core_node/src/parse.rs#L179">swc/bindings/binding_core_node/src/parse.rs#L179</a></p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="kd">let</span> <span class="n">program</span> <span class="o">=</span> <span class="n">try_with</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="n">ErrorFormat</span><span class="o">::</span><span class="n">Normal</span><span class="p">,</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="p">{</span>
    <span class="c1">// ....</span>
<span class="p">}).</span><span class="n">convert_err</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
</pre></div>

</code></pre>
<p>我们需要抛出 JVM 的异常，所以要实现 JVM 的 <code>MapErr&lt;T&gt;</code> trait，将Rust异常转为 <code>jni</code>的异常，让<code>jni</code>抛出到 JVM。</p>
<p>抄一下 SWC 的 <code>MapErr&lt;T&gt;</code> trait。</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">MapErr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;:</span> <span class="n">Into</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">anyhow</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">convert_err</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SwcResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">into</span><span class="p">().</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span> <span class="n">SwcException</span><span class="o">::</span><span class="n">SwcAnyException</span> <span class="p">{</span>
            <span class="n">msg</span><span class="o">:</span> <span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p><code>Result</code>实现<code>MapErr&lt;T&gt;</code></p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MapErr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">anyhow</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{}</span>
</pre></div>

</code></pre>
<p>这里 <code>jni</code> 抛出异常需要注意，函数依然需要返回值，一般返回空串。这里 <a href="https://github.com/jni-rs/jni-rs/issues/76">jni-rs#76</a> 解释了原因。</p>
<blockquote>
<p>You still have to return to the JVM, even if you&#39;ve thrown an exception. Remember that unwinding across the ffi boundary is always undefined behavior, so any panics need to be caught and recovered from in your extern functions.</p>
</blockquote>
<p>最后异常处理像这样</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="kd">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">try_with</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="n">ErrorFormat</span><span class="o">::</span><span class="n">Normal</span><span class="p">,</span> <span class="o">|</span><span class="n">handler</span><span class="o">|</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}).</span><span class="n">convert_err</span><span class="p">();</span>

<span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
    <span class="nb">Ok</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">e</span> <span class="p">{</span>
            <span class="n">SwcException</span><span class="o">::</span><span class="n">SwcAnyException</span> <span class="p">{</span> <span class="n">msg</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="n">env</span><span class="p">.</span><span class="n">throw</span><span class="p">(</span><span class="n">msg</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">JString</span><span class="o">::</span><span class="n">default</span><span class="p">().</span><span class="n">into_raw</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<h3 id="swcnative">SwcNative</h3>
<p>实现Rust编译成动态库，下一步就需要实现 JVM 侧胶水代码，下面是 Kotlin 实现。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SwcNative</span> <span class="p">{</span>
    <span class="n">init</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s">&quot;swc_jni&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">@Throws</span><span class="p">(</span><span class="n">RuntimeException</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
    <span class="n">external</span> <span class="k">fun</span> <span class="nf">parseSync</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">String</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>JVM 加载<code>swc_jni</code>时，会按照规则从文件系统寻找动态库，但是不会从 jar 的 <code>resources</code>目录寻找。所以，通过<code>System.loadLibrary(&quot;swc_jni&quot;)</code>如果本地没有<code>swc_jni</code>动态库，就会加载失败。用户从 maven 安装，本地肯定没有<code>swc_jni</code>。</p>
<p>解决方案，参考这个回答 <a href="https://stackoverflow.com/questions/23189776/load-native-library-from-class-path">Load Native Library from Class path</a>，如果<code>System.loadLibrary(&quot;swc_jni&quot;)</code> 加载失败就将 jar 的动态库复制到临时目录再加载。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre>    <span class="n">init</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s">&quot;swc_jni&quot;</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">UnsatisfiedLinkError</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 加载失败，复制DLL到临时目录</span>
            <span class="k">val</span> <span class="py">dllPath</span> <span class="p">=</span> <span class="n">DllLoader</span><span class="p">.</span><span class="n">copyDll2Temp</span><span class="p">(</span><span class="s">&quot;swc_jni&quot;</span><span class="p">)</span>
            <span class="c1">// 再次加载</span>
            <span class="n">System</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">dllPath</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</code></pre>
<h3 id="-">小结</h3>
<p>像其他方法就像<code>parse_sync</code>依葫芦画瓢实现就可以了。</p>
<p>到这一步我们已经可以在 JVM 里的编译 JS 了。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">SwcNative</span><span class="p">().</span><span class="n">parseSync</span><span class="p">(</span>
    <span class="s">&quot;var foo = &#39;bar&#39;&quot;</span><span class="p">,</span> 
    <span class="s">&quot;&quot;&quot;{&quot;</span><span class="n">syntax</span><span class="s">&quot;: &quot;</span><span class="n">ecmascript</span><span class="s">&quot;;}&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s">&quot;test.js&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

</code></pre>
<details><summary>output string</summary><code>json
{
  &quot;type&quot;: &quot;Module&quot;,
  &quot;span&quot;: {
    &quot;start&quot;: 0,
    &quot;end&quot;: 15,
    &quot;ctxt&quot;: 0
  },
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;VariableDeclaration&quot;,
      &quot;span&quot;: {
        &quot;start&quot;: 0,
        &quot;end&quot;: 15,
        &quot;ctxt&quot;: 0
      },
      &quot;kind&quot;: &quot;var&quot;,
      &quot;declare&quot;: false,
      &quot;declarations&quot;: [
        {
          &quot;type&quot;: &quot;VariableDeclarator&quot;,
          &quot;span&quot;: {
            &quot;start&quot;: 4,
            &quot;end&quot;: 15,
            &quot;ctxt&quot;: 0
          },
          &quot;id&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 4,
              &quot;end&quot;: 7,
              &quot;ctxt&quot;: 2
            },
            &quot;value&quot;: &quot;foo&quot;,
            &quot;optional&quot;: false,
            &quot;typeAnnotation&quot;: null
          },
          &quot;init&quot;: {
            &quot;type&quot;: &quot;StringLiteral&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 10,
              &quot;end&quot;: 15,
              &quot;ctxt&quot;: 0
            },
            &quot;value&quot;: &quot;bar&quot;,
            &quot;raw&quot;: &quot;&#39;bar&#39;&quot;
          },
          &quot;definite&quot;: false
        }
      ]
    }
  ],
  &quot;interpreter&quot;: null
}</code></code></details>
<h2 id="kotlin-ast-dsl">Kotlin AST DSL</h2>
<p>现在我们得到 AST JSON 字符串，如果想要对AST进行操作还是很不方便的。我们需要 JSON 字符串将其转换为类，这样遍历、修改都会非常方便。</p>
<p>而且 <code>parseSync</code> 的第二个<code>options</code>也不知道类型，需要约束配置项。</p>
<p>那我们如何在 Kotlin 实现 SWC AST 和配置项参数的类型描述呢？</p>
<p>我尝试过是 AI 将 Rust 转换为 Kotlin，效果相当不错。唯一的问题的就是需要氪金，我承认没钱是我的问题。</p>
<p>从头写 SWC 类定义？工作做恐怕有的大了。SWC 有 200+ 的 AST 和配置项类型。</p>
<p>最好的解决方式就是通过脚本来生成 Kotlin 类。恰好，SWC 提供了 TS 声明文件 <a href="https://www.npmjs.com/package/@swc/types">@swc/types</a>。</p>
<h3 id="-swc-types">@swc/types</h3>
<p>打开 <code>@swc/types</code> 的声明文件，里面都是 <code>type</code> 和 <code>interface</code> 声明，结构非常简单。</p>
<p>可以分为一下情况:</p>
<ol>
<li>type alias<ol>
<li>literal union type: <code>type T = &#39;foo&#39; | &#39;bar&#39;</code></li>
<li>primary union type: <code>type T = string | number</code></li>
<li>type alias and object literal type: <code>type T = S &amp; { foo: string }</code></li>
<li>type alias union type: <code>type T = S | E</code></li>
</ol>
</li>
<li>interface</li>
</ol>
<p>Type alias 的情况相对复杂，主要还是因为 JS 的灵活性。</p>
<h3 id="type-alias">type alias</h3>
<p>对于一些特殊情况我们需要减少类型的动态性，方便我们进行处理。</p>
<p>像 <code>T | T[]</code> 我们可以转为 <code>T[]</code>，避免在 Kotlin 里无法定义类型。</p>
<p>比如：</p>
<pre><code class="lang-ts"><div class="highlight"><pre><span class="kr">export</span> <span class="kr">interface</span> <span class="nx">Config</span> <span class="p">{</span>
    <span class="nx">test?</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kt">string</span><span class="p">[];</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>就转换为：</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Config</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">test</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;?</span> <span class="p">=</span> <span class="k">null</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>像 <code>props: &#39;foo&#39; | &#39;bar&#39;</code> 这样的字面量联合类型应该直接转为基础类型： <code>val props: String?</code>。</p>
<p><code>type T = S &amp; { foo: string }</code> 需要将对象字面量类型提取单独的类型，T 来继承 S 和 提取出来的新类型。转换成 kotlin应该是这样的：</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">interface</span> <span class="n">BaseT</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">foo</span><span class="p">:</span> <span class="n">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">T</span> <span class="p">:</span> <span class="n">S</span><span class="p">,</span> <span class="n">BaseT</span> <span class="p">{}</span>
</pre></div>

</code></pre>
<h3 id="interface">interface</h3>
<p>对于 <code>interface</code> 处理，分为3部分：1. TS interface 转为 Kotlin 类；2. 继承关系；3. 序列化。</p>
<h4 id="ts-interface-kotlin-">TS interface 转为 Kotlin 类</h4>
<p>定义个 <code>KotlinClass</code> 来表示要装换成的 Kotlin 类。这样实现<code>toString()</code>即可方便地将其转为 kotlin 类。</p>
<pre><code class="lang-ts"><div class="highlight"><pre><span class="kr">export</span> <span class="kr">class</span> <span class="nx">KotlinClass</span> <span class="p">{</span>
    <span class="nx">klassName</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nx">headerComment</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">annotations</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">modifier</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">parents</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">properties</span>: <span class="kt">KotlinClassProperty</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>通过遍历 TS interface 的 AST，就可以生成 <code>KotlinClass</code>。</p>
<p>在遍历 interface 属性时，需要递归遍历父类的属性，继承自父类型的属性需要将<code>KotlinClassProperty.isOverride</code>设为 true，方便生成 kotlin 类是加上<code>override</code>修饰符。</p>
<pre><code class="lang-ts"><div class="highlight"><pre><span class="kr">class</span> <span class="nx">KotlinClassProperty</span> <span class="p">{</span>
    <span class="nx">modifier</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;var&#39;</span>
    <span class="nx">name</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">type</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">comment</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">defaultValue</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="nx">isOverride</span>: <span class="kt">boolean</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="nx">discriminator</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;type&#39;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<h4 id="-">继承关系</h4>
<p>TS interface 直接继承的父 interface 直接加入 <code>KotlinClass.parents</code> 数组即可。</p>
<p>但是，对于 <code>type T = S | E</code> 需要进行单独处理</p>
<p>举个例子</p>
<pre><code class="lang-ts"><div class="highlight"><pre><span class="kr">export</span> <span class="kr">interface</span> <span class="nx">VariableDeclarator</span> <span class="kr">extends</span> <span class="nx">Node</span><span class="p">,</span> <span class="nx">HasSpan</span> <span class="p">{</span>
    <span class="nx">init?</span>: <span class="kt">Expression</span><span class="p">;</span>

    <span class="c1">// other props...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="nx">type</span> <span class="nx">Expression</span> <span class="o">=</span>
    <span class="o">|</span> <span class="nx">ThisExpression</span>
    <span class="o">|</span> <span class="nx">ArrayExpression</span>
    <span class="o">|</span> <span class="p">....</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">ArrayExpression</span> <span class="kr">extends</span> <span class="nx">ExpressionBase</span>  <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>这里 Expression 是所有 <code>XxxExpression</code> 的父类型。这样<code>variableDeclarator.init = thisExpression</code> 或者 <code>variableDeclarator.init = arrayExpression</code> 赋值才合法。</p>
<p>因为 TS 里 <code>Expression</code> 是 type alias 转换 kotlin 要变成一个空接口。 转换成 Kotlin 结果像这样</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">interface</span> <span class="n">Expression</span> <span class="p">{}</span>

<span class="k">class</span> <span class="nc">VariableDeclarator</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">HasSpan</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">init</span><span class="p">:</span> <span class="n">Expression</span><span class="p">?;</span>

    <span class="c1">// other props...</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">ArrayExpression</span> <span class="p">:</span> <span class="n">ExpressionBase</span><span class="p">,</span> <span class="n">Expression</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>所以，对于 <code>type T = S | E</code>，<code>T</code> 是 <code>S</code> 和 <code>E</code>的父类，需要将 <code>T</code> 加入<code>S</code>,<code>E</code> 的 <code>KotlinClass.parents</code> 数组。</p>
<h4 id="-">序列化</h4>
<p>AST 节点序列化时，会遇到多态序列化的问题。</p>
<p>比如，序列化<code>Expression</code>，而<code>Expression</code>是空接口，这时<code>toJson</code>就不知道如何处理<code>ThisExpression</code>和<code>ArrayExpression</code>的属性，这时只能抛出异常或者输出空对象，都不符合我们的期望。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">val</span> <span class="py">thisExpression</span><span class="p">:</span> <span class="n">ThisExpression</span> <span class="p">=</span> <span class="n">ThisExpression</span><span class="p">()</span>
<span class="k">val</span> <span class="py">arrayExpression</span><span class="p">:</span> <span class="n">ArrayExpression</span> <span class="p">=</span> <span class="n">ArrayExpression</span><span class="p">()</span>

<span class="k">var</span> <span class="py">expression</span><span class="p">:</span> <span class="n">Expression</span> <span class="p">=</span> <span class="n">thisExpression</span>
<span class="n">toJson</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>

<span class="n">expression</span> <span class="p">=</span> <span class="n">arrayExpression</span>
<span class="n">toJson</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
</pre></div>

</code></pre>
<p>反序列化也是一样的。<code>parseJson</code> 也不知道将字符串转为<code>ThisExpression</code>还是<code>ArrayExpression</code>。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">val</span> <span class="py">thisExpression</span> <span class="p">=</span> <span class="s">&quot;&quot;&quot; {&quot;</span><span class="k">type</span><span class="s">&quot;:&quot;</span><span class="n">ThisExpression</span><span class="s">&quot;, &quot;</span><span class="n">props</span><span class="s">&quot;: &quot;</span><span class="n">any</span> <span class="n">value</span><span class="s">&quot; } &quot;&quot;&quot;</span>
<span class="k">val</span> <span class="py">arrayExpression</span> <span class="p">=</span> <span class="s">&quot;&quot;&quot; {&quot;</span><span class="k">type</span><span class="s">&quot;:&quot;</span><span class="n">ThisExpression</span><span class="s">&quot;, &quot;</span><span class="n">elements</span><span class="s">&quot;: [] } &quot;&quot;&quot;</span>

<span class="k">var</span> <span class="py">expression</span><span class="p">:</span> <span class="n">Expression</span> <span class="p">=</span> <span class="n">parseJson</span><span class="p">(</span><span class="n">thisExpression</span><span class="p">)</span>
<span class="k">var</span> <span class="py">expression</span><span class="p">:</span> <span class="n">Expression</span> <span class="p">=</span> <span class="n">parseJson</span><span class="p">(</span><span class="n">arrayExpression</span><span class="p">)</span>
</pre></div>

</code></pre>
<p>使用 kotlinx serialization 来序列化，它支持<a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md">多态序列化</a>，需要将改造kotlin代码。</p>
<p>在类上注解<code>JsonClassDiscriminator</code>标明通过哪个字段来区分类型，<code>SerialName</code>注解标明序列后类型的名称。反序列化时可以根据这个类型名称找到具体类型。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">interface</span> <span class="n">ArrayExpression</span> <span class="p">:</span> <span class="n">ExpressionBase</span><span class="p">,</span> <span class="n">Expression</span> <span class="p">{</span>
    <span class="c1">// ....</span>
<span class="p">}</span>

<span class="n">@Serializable</span>
<span class="n">@JsonClassDiscriminator</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">)</span>
<span class="n">@SerialName</span><span class="p">(</span><span class="s">&quot;ArrayExpression&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ArrayExpressionImpl</span> <span class="p">:</span> <span class="n">ArrayExpression</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">ThisExpression</span> <span class="p">:</span> <span class="n">ExpressionBase</span><span class="p">,</span> <span class="n">Expression</span> <span class="p">{</span>
    <span class="c1">// ....</span>
<span class="p">}</span>

<span class="n">@Serializable</span>
<span class="n">@JsonClassDiscriminator</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">)</span>
<span class="n">@SerialName</span><span class="p">(</span><span class="s">&quot;ThisExpression&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ThisExpressionImpl</span> <span class="p">:</span> <span class="n">ThisExpression</span> <span class="p">{</span>
    <span class="c1">// ....</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>为了序列化和反序列化是能够正确找到具体类型，还需要定义<code>SerializersModule</code>。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">val</span> <span class="py">swcSerializersModule</span> <span class="p">=</span> <span class="n">SerializersModule</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">polymorphic</span><span class="p">(</span><span class="n">Expression</span><span class="o">::</span><span class="k">class</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">subclass</span><span class="p">(</span><span class="n">ThisExpressionImpl</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
        <span class="n">subclass</span><span class="p">(</span><span class="n">ArrayExpressionImpl</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="n">polymorphic</span><span class="p">(</span><span class="n">ThisExpression</span><span class="o">::</span><span class="k">class</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">subclass</span><span class="p">(</span><span class="n">ThisExpressionImpl</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">polymorphic</span><span class="p">(</span><span class="n">ArrayExpression</span><span class="o">::</span><span class="k">class</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">subclass</span><span class="p">(</span><span class="n">ArrayExpressionImpl</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>这样就可以正常序列化多态类型了</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">val</span> <span class="py">json</span> <span class="p">=</span> <span class="n">Json</span> <span class="p">{</span>
    <span class="n">classDiscriminator</span> <span class="p">=</span> <span class="s">&quot;syntax&quot;</span>
    <span class="n">serializersModule</span> <span class="p">=</span> <span class="n">configSerializer</span>
<span class="p">}</span>

<span class="n">json</span><span class="p">.</span><span class="n">decodeFromString</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&gt;(</span><span class="s">&quot;&quot;&quot; {&quot;</span><span class="k">type</span><span class="s">&quot;:&quot;</span><span class="n">ThisExpression</span><span class="s">&quot;, &quot;</span><span class="n">elements</span><span class="s">&quot;: [] } &quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">val</span> <span class="py">arrayExpression</span><span class="p">:</span> <span class="n">Expression</span> <span class="p">=</span> <span class="n">ArrayExpression</span><span class="p">()</span>
<span class="n">json</span><span class="p">.</span><span class="n">encodeToString</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&gt;(</span><span class="n">arrayExpression</span><span class="p">)</span>
</pre></div>

</code></pre>
<h3 id="dsl">DSL</h3>
<p>我们生成好了 AST 和配置项的类定义，如果直接使用类来构建配置或者 AST 会发现不太优雅和方便。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
</pre></div>

</code></pre>
<details><summary>SWC compile output string</summary><code>json
    {
      &quot;type&quot;: &quot;VariableDeclaration&quot;,
      &quot;span&quot;: {
        &quot;start&quot;: 0,
        &quot;end&quot;: 17,
        &quot;ctxt&quot;: 0
      },
      &quot;kind&quot;: &quot;const&quot;,
      &quot;declare&quot;: false,
      &quot;declarations&quot;: [
        {
          &quot;type&quot;: &quot;VariableDeclarator&quot;,
          &quot;span&quot;: {
            &quot;start&quot;: 6,
            &quot;end&quot;: 17,
            &quot;ctxt&quot;: 0
          },
          &quot;id&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 6,
              &quot;end&quot;: 9,
              &quot;ctxt&quot;: 2
            },
            &quot;value&quot;: &quot;foo&quot;,
            &quot;optional&quot;: false,
            &quot;typeAnnotation&quot;: null
          },
          &quot;init&quot;: {
            &quot;type&quot;: &quot;StringLiteral&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 12,
              &quot;end&quot;: 17,
              &quot;ctxt&quot;: 0
            },
            &quot;value&quot;: &quot;bar&quot;,
            &quot;raw&quot;: &quot;&#39;bar&#39;&quot;
          },
          &quot;definite&quot;: false
        }
      ]
    }</code></details>
<p>上面 JS 代码，如果我们 Kotlin 来构建 AST</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">VariableDeclarationImpl</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
    <span class="n">span</span> <span class="p">=</span> <span class="n">Span</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">17</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">kind</span> <span class="p">=</span> <span class="err">&#39;</span><span class="n">const</span><span class="err">&#39;</span>
    <span class="n">declare</span> <span class="p">=</span> <span class="k">false</span>
    <span class="n">declarations</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span>
        <span class="n">VariableDeclaratorImpl</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
            <span class="n">span</span> <span class="p">=</span> <span class="n">Span</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="m">17</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
            <span class="n">id</span> <span class="p">=</span> <span class="n">IdentifierImpl</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
                <span class="n">span</span> <span class="p">=</span> <span class="n">span</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
                <span class="n">value</span> <span class="p">=</span> <span class="s">&quot;foo&quot;</span>
            <span class="p">}</span>
            <span class="n">init</span> <span class="p">=</span> <span class="n">StringLiteralImpl</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
                <span class="n">span</span> <span class="p">=</span> <span class="n">Span</span><span class="p">(</span><span class="m">12</span><span class="p">,</span><span class="m">17</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
                <span class="n">value</span> <span class="p">=</span> <span class="s">&quot;bar&quot;</span>
                <span class="n">raw</span> <span class="p">=</span> <span class="s">&quot;&#39;bar&#39;&quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">)</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>通过<code>apply</code>来调用简化的属性设置。相对面条式代码，通过<code>apply</code>已经比较简洁。还能简洁一点。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">variableDeclaration</span>  <span class="p">{</span>
    <span class="n">span</span> <span class="p">=</span> <span class="n">span</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">17</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="n">kind</span> <span class="p">=</span> <span class="err">&#39;</span><span class="n">const</span><span class="err">&#39;</span>
    <span class="n">declare</span> <span class="p">=</span> <span class="k">false</span>
    <span class="n">declarations</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span>
        <span class="n">variableDeclaratorImpl</span> <span class="p">{</span>
            <span class="n">span</span> <span class="p">=</span> <span class="n">span</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="m">17</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
            <span class="n">id</span> <span class="p">=</span> <span class="n">identifier</span> <span class="p">{</span>
                <span class="n">span</span> <span class="p">=</span> <span class="n">span</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
                <span class="n">value</span> <span class="p">=</span> <span class="s">&quot;foo&quot;</span>
            <span class="p">}</span>
            <span class="n">init</span> <span class="p">=</span> <span class="n">stringLiteral</span> <span class="p">{</span>
                <span class="n">span</span> <span class="p">=</span> <span class="n">span</span><span class="p">(</span><span class="m">12</span><span class="p">,</span><span class="m">17</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
                <span class="n">value</span> <span class="p">=</span> <span class="s">&quot;bar&quot;</span>
                <span class="n">raw</span> <span class="p">=</span> <span class="s">&quot;&#39;bar&#39;&quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">)</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>现在的 DSL 已经很像输出 AST JSON，写起来也非常简单直白。</p>
<p>需要DSL写法的类，都需要<code>SwcDslMarker</code>注解标记。<code>SwcDslMarker</code>主要是为了限制作用域，避免访问外层作用域。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">@DslMarker</span>
<span class="k">annotation</span> <span class="k">class</span> <span class="nc">SwcDslMarker</span>

<span class="n">@SwcDslMarker</span>
<span class="k">class</span> <span class="nc">VariableDeclarationImpl</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">variableDeclaration</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="n">VariableDeclaration</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">VariableDeclaration</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">VariableDeclarationImpl</span><span class="p">().</span><span class="n">apply</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>如何实现可以参考官方文档：<a href="https://kotlinlang.org/docs/type-safe-builders.html#scope-control-dslmarker">kotlin -- Type-safe builders</a></p>
<h4 id="dsl-extension-function">DSL extension function</h4>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">interface</span> <span class="n">VariableDeclarator</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">HasSpan</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">init</span><span class="p">:</span> <span class="n">Expression</span><span class="p">?;</span>
    <span class="c1">// other props...</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>对于<code>VariableDeclarator</code>接口，其init字段类型是<code>Expression</code>，意味着它的右值可以是<code>arrayExpression</code>、<code>thisExpression</code>等任意子类型。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">variableDeclarator</span> <span class="p">{</span>
    <span class="n">init</span> <span class="p">=</span> <span class="n">arrayExpression</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="c1">// or</span>
    <span class="n">init</span> <span class="p">=</span> <span class="n">thisExpression</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>所以对于<code>VariableDeclarator</code>它应该有创建所有 <code>Expression</code> 子类的方法。通过扩展函数来实现来添加创建<code>Expression</code> 子类。</p>
<p>我们在解析<code>@swc/types</code>声明文件时，需要检查属性类型，如果是转换成Kotlin后是类，那就找出其所有非中间子类，然后为其生成扩展函数。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="k">fun</span> <span class="nf">VariableDeclarator</span><span class="p">.</span><span class="n">arrayExpression</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="n">ArrayExpression</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">ArrayExpression</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ArrayExpressionImpl</span><span class="p">().</span><span class="n">apply</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>这样在 <code>variableDeclarator {}</code> 里就可以通过 <code>arrayExpression {}</code> 函数构建<code>Expression</code>类。</p>
<h4 id="templateliteral-vs-tstemplateliteraltype"><code>TemplateLiteral</code> vs <code>TsTemplateLiteralType</code></h4>
<p>这里还有个特殊情况需要处理。<code>TemplateLiteral</code>跟<code>TsTemplateLiteralType</code>冲突了，他们的<code>type</code>都是<code>&quot;TemplateLiteral&quot;</code>。这使得 DSL 构建的 AST 无法序列化。参见 rust 的结构体定义。</p>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="c1">// https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/crates/swc_ecma_ast/src/typescript.rs#L823</span>
<span class="cp">#[ast_node(</span><span class="s">&quot;TemplateLiteral&quot;</span><span class="cp">)]</span>
<span class="cp">#[derive(Eq, Hash, EqIgnoreSpan)]</span>
<span class="cp">#[cfg_attr(feature = </span><span class="s">&quot;arbitrary&quot;</span><span class="cp">, derive(arbitrary::Arbitrary))]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TsTplLitType</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<pre><code class="lang-rust"><div class="highlight"><pre><span class="c1">// https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/crates/swc_ecma_ast/src/expr.rs#L1060</span>
<span class="cp">#[ast_node(</span><span class="s">&quot;TemplateLiteral&quot;</span><span class="cp">)]</span>
<span class="cp">#[derive(Eq, Hash, EqIgnoreSpan)]</span>
<span class="cp">#[cfg_attr(feature = </span><span class="s">&quot;arbitrary&quot;</span><span class="cp">, derive(arbitrary::Arbitrary))]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Tpl</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">span</span><span class="o">:</span> <span class="n">Span</span><span class="p">,</span>

    <span class="cp">#[cfg_attr(feature = </span><span class="s">&quot;serde-impl&quot;</span><span class="cp">, serde(rename = </span><span class="s">&quot;expressions&quot;</span><span class="cp">))]</span>
    <span class="k">pub</span> <span class="n">exprs</span><span class="o">:</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;&gt;</span><span class="p">,</span>

    <span class="k">pub</span> <span class="n">quasis</span><span class="o">:</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">TplElement</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>这两个类型需要单独处理，不由脚本来生成。</p>
<p>由一个类同时实现<code>TemplateLiteral</code>、<code>TsTemplateLiteralType</code>。使用时再向上转型为<code>TemplateLiteral</code>、<code>TsTemplateLiteralType</code>。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="c1">// ignore annotation</span>
<span class="n">interface</span> <span class="n">TemplateLiteral</span> <span class="p">:</span> <span class="n">ExpressionBase</span><span class="p">,</span> <span class="n">Expression</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">expressions</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&gt;?</span>
    <span class="k">var</span> <span class="py">quasis</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">TemplateElement</span><span class="p">&gt;?</span>
    <span class="k">override</span> <span class="k">var</span> <span class="py">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">?</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">TsTemplateLiteralType</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">HasSpan</span><span class="p">,</span> <span class="n">TsLiteral</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">types</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">TsType</span><span class="p">&gt;?</span>
    <span class="k">var</span> <span class="py">quasis</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">TemplateElement</span><span class="p">&gt;?</span>
    <span class="k">override</span> <span class="k">var</span> <span class="py">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">?</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TemplateLiteralImpl</span> <span class="p">:</span> <span class="n">TemplateLiteral</span><span class="p">,</span> <span class="n">TsTemplateLiteralType</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">var</span> <span class="py">types</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">TsType</span><span class="p">&gt;?</span> <span class="p">=</span> <span class="k">null</span>
    <span class="k">override</span> <span class="k">var</span> <span class="py">expressions</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">&gt;?</span> <span class="p">=</span> <span class="k">null</span>
    <span class="k">override</span> <span class="k">var</span> <span class="py">quasis</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">TemplateElement</span><span class="p">&gt;?</span> <span class="p">=</span> <span class="k">null</span>
    <span class="k">override</span> <span class="k">var</span> <span class="py">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
<span class="p">}</span>

<span class="n">typealias</span> <span class="n">TsTemplateLiteralTypeImpl</span> <span class="p">=</span> <span class="n">TemplateLiteralImpl</span>
</pre></div>

</code></pre>
<h3 id="-parsesync">新的 <code>parseSync</code></h3>
<p>现在我们可以升级<code>parseSync</code>签名了。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">@Throws</span><span class="p">(</span><span class="n">RuntimeException</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
<span class="k">fun</span> <span class="nf">parseSync</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">ParserConfig</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">Program</span> 
</pre></div>

</code></pre>
<p>现在使用时可以保证类型安全和类型提示了。</p>
<pre><code class="lang-kotlin"><div class="highlight"><pre><span class="n">const</span> <span class="n">program</span> <span class="p">=</span> <span class="n">SwcNative</span><span class="p">().</span><span class="n">parseSync</span><span class="p">(</span>
    <span class="s">&quot;&quot;&quot;</span>
    <span class="n">function</span> <span class="n">App</span><span class="p">()</span> <span class="p">{</span>
       <span class="k">return</span> <span class="p">&lt;</span><span class="n">div</span><span class="p">&gt;</span><span class="n">App</span><span class="p">&lt;/</span><span class="n">div</span><span class="p">&gt;</span>
    <span class="p">}</span>
    <span class="s">&quot;&quot;&quot;.trimIndent(),</span>
    <span class="n">esParseOptions</span> <span class="p">{</span>
        <span class="n">jsx</span> <span class="p">=</span> <span class="k">true</span>
        <span class="n">target</span> <span class="p">=</span> <span class="s">&quot;es5&quot;</span>
    <span class="p">},</span>
    <span class="s">&quot;temp.js&quot;</span>
<span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">program</span> <span class="k">is</span> <span class="n">Module</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">program</span><span class="p">.</span><span class="n">body</span><span class="o">?.</span><span class="k">get</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="k">is</span> <span class="n">FunctionDeclaration</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<h2 id="-">总结</h2>
<p>到这里，解释了 SWC JVM binding 的实现思路和核心实现要点。1. SWC 支持 JNI；2. AST JSON 序列化成 Kotlin 类；3. 通过 DSL 描述 AST和配置项。</p>
<p>一些细碎的内容没有涉及到，比如，Kotlin 生成脚本一些边界情况的处理、Rust交叉编译等。对细节感兴趣可以阅读源码<a href="https://github.com/yidafu/swc-binding">yidafu/swc-binding</a>。</p>
<p>如果你有需求在 JVM 编译 JS，SWC JVM binding 已发布到 Maven 中央仓库，请使用 <a href="https://mvnrepository.com/artifact/dev.yidafu.swc/swc-binding">dev.yidafu.swc:swc-binding:0.5.0</a></p>
<p>其他问题，欢迎<a href="https://github.com/yidafu/swc-binding/issues/new">提Issue</a>。</p>
<blockquote>
<p>思考永无止境</p>
</blockquote>
<script src="prism.js" ></script></div></body>
</html>
